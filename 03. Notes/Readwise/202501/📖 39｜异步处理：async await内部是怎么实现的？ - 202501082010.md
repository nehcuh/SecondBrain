---
title: ğŸ“– 39ï½œå¼‚æ­¥å¤„ç†ï¼šasync awaitå†…éƒ¨æ˜¯æ€ä¹ˆå®ç°çš„ï¼Ÿ
createdAt: 2025-01-08 20:10
notebook: "[[ğŸ—ï¸ Rust ç¼–ç¨‹ç¬¬ä¸€è¯¾]]"
allDay: 
startTime: 
endTime: 
date: 2025-01-08
project: 
area: 
resource: 
archived: 
tags:
  - "#note/ğŸŒ±"
  - "#readwise"
links: 
due: 2025-01-08
nextReview: 2025-01-15
status: "#processing"
---

# åŸæ–‡æ‘˜è¦
> [!tip] 
> å°†åŸå§‹æ–‡ç« ä¸­çš„è¾ƒä¸ºé‡è¦çš„ä¿¡æ¯ã€Œæ‘˜å½•ã€åˆ°ç¬”è®°å½“ä¸­ï¼Œå¯¹ä¸€äº›ç¨å¾®é‡è¦çš„ä¿¡æ¯è¿›è¡Œã€ŒåŠ ç²—å¤„ç†ã€ï¼ˆç”¨ä¸€å¯¹Â ** åŒ…è£¹ç€å†…å®¹ï¼‰ï¼Œåœ¨æœªæ¥ã€Œå›çœ‹ç¬”è®°ã€æ—¶å¿«é€Ÿç†è§£ç¬¬ä¸€å±‚ä¿¡æ¯

æˆ‘ä»¬ä¼šç»§ç»­å›´ç»•ç€ Future è¿™ä¸ªç®€çº¦å´åˆå¹¶ä¸ç®€å•çš„æ¥å£ï¼Œæ¥æ¢è®¨ä¸€äº›åŸç†æ€§çš„ä¸œè¥¿ï¼Œä¸»è¦æ˜¯ `Context` å’Œ `Pin` è¿™ä¸¤ä¸ªç»“æ„ï¼š

```rust
pub trait Future {
	type Output;
	fn poll(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output>;
}
```

## Waker çš„è°ƒç”¨æœºåˆ¶
å…ˆæ¥çœ‹è¿™ä¸ªæ¥å£çš„ `Context` æ˜¯ä¸ªä»€ä¹ˆä¸œè¥¿ã€‚

ä¸ŠèŠ‚è¯¾æˆ‘ä»¬ç®€å•è®²è¿‡ `executor` é€šè¿‡è°ƒç”¨ `poll` æ–¹æ³•æ¥è®© Future ç»§ç»­å¾€ä¸‹æ‰§è¡Œï¼Œ å¦‚æœ `poll` æ–¹æ³•è¿”å› `Poll::Pending`ï¼Œ å°±é˜»å¡ Futureï¼Œ ç›´åˆ° `reactor` æ”¶åˆ°äº†æŸä¸ªäº‹ä»¶ï¼Œ ç„¶åè°ƒç”¨ `Waker.wake()` æŠŠ Future å”¤é†’ã€‚ è¿™ä¸ª Waker æ˜¯å“ªæ¥çš„å‘¢ï¼Ÿ

å…¶å®ï¼Œå®ƒéšå«åœ¨ Context ä¸­ï¼š

```rust
pub struct Context<'a> {
	waker: &'a Waker,
	_marker: PhantomData<fn(&'a ()) -> &'a ()>
}
```

æ‰€ä»¥ï¼Œ`Context` å°±æ˜¯ `Waker` çš„ä¸€ä¸ªå°è£…ã€‚å¦‚æœä½ å»çœ‹ `Waker` çš„å®šä¹‰å’Œç›¸å…³çš„ä»£ç ï¼Œä¼šå‘ç°å®ƒéå¸¸æŠ½è±¡ï¼Œå†…éƒ¨ä½¿ç”¨äº†ä¸€ä¸ª vtable æ¥å…è®¸å„ç§å„æ ·çš„ waker çš„è¡Œä¸ºï¼š

```rust
pub struct RawWakerVTable {
	clone: unsafe fn(*const ()) -> RawWaker,
	wake: unsafe fn(*const ()),
	wake_by_ref: unsafe fn(*const ()),
	drop: unsafe fn(*const ())
}
```

Rust è‡ªèº«å¹¶ä¸æä¾›å¼‚æ­¥è¿è¡Œæ—¶ï¼Œå®ƒåªåœ¨æ ‡å‡†åº“é‡Œè§„å®šäº†ä¸€äº›åŸºæœ¬çš„æ¥å£ï¼Œè‡³äºæ€ä¹ˆå®ç°ï¼Œå¯ä»¥ç”±å„ä¸ªè¿è¡Œæ—¶ï¼ˆå¦‚ `tokio`ï¼‰è‡ªè¡Œå†³å®šã€‚**æ‰€ä»¥åœ¨æ ‡å‡†åº“ä¸­ï¼Œä½ åªä¼šçœ‹åˆ°è¿™äº›æ¥å£çš„å®šä¹‰ï¼Œä»¥åŠâ€œé«˜å±‚â€æ¥å£çš„å®ç°**ï¼Œæ¯”å¦‚ `Waker` ä¸‹çš„ `wake` æ–¹æ³•ï¼Œåªæ˜¯è°ƒç”¨äº† `vtable` é‡Œçš„ `wake()` è€Œå·²ï¼š

```rust
impl Waker {
	// Wake up the task associated with this `Waker`
	#[inline]
	pub fn wake(self) {
		// The actual wakeup call is delegated through a virtual function call
		// to the implementation which is defined by the executor.
		let wake = self.waker.vtable.wake;
		let data = self.waker.data;

		// Don't call `drop` -- the waker will be consumed by `wake`.
		std::mem::forget(self);

		// SAFETY: This is safe because `Waker::from_raw` is the only way
		// to initialize `wake` and `data` requiring the user to acknowledge
		// that the contract of `RawWaker` is upheld.
		unsafe { (wake)(data) };
	}
}
```

å¦‚æœä½ æƒ³é¡ºè—¤æ‘¸ç“œæ‰¾åˆ° vtable æ˜¯æ€ä¹ˆè®¾ç½®çš„ï¼Œå´å‘ç°ä¸€åˆ‡çº¿ç´¢éƒ½æ‚„æ— å£°æ¯åœ°ä¸­æ–­äº†ï¼Œé‚£æ˜¯å› ä¸ºï¼Œå…·ä½“çš„å®ç°å¹¶ä¸åœ¨æ ‡å‡†åº“ä¸­ï¼Œè€Œæ˜¯åœ¨ç¬¬ä¸‰æ–¹çš„å¼‚æ­¥è¿è¡Œæ—¶é‡Œï¼Œæ¯”å¦‚ `tokio`ã€‚

### async ç©¶ç«Ÿç”Ÿæˆäº†ä»€ä¹ˆï¼Ÿ
æˆ‘ä»¬æ¥ä¸‹æ¥çœ‹ `Pin`ã€‚è¿™æ˜¯ä¸€ä¸ªå¥‡æ€ªçš„æ•°æ®ç»“æ„ï¼Œæ­£å¸¸æ•°æ®ç»“æ„çš„æ–¹æ³•éƒ½æ˜¯ç›´æ¥ä½¿ç”¨ `self / &self / &mut self`ï¼Œå¯æ˜¯ `poll()` å´ä½¿ç”¨äº† `Pin<&mut self>`ï¼Œä¸ºä»€ä¹ˆï¼Ÿ

ä¸ºäº†è®²æ˜ç™½ `Pin`ï¼Œæˆ‘ä»¬å¾—å¾€å‰è¿½è¸ªä¸€æ­¥ï¼Œçœ‹çœ‹äº§ç”Ÿ Future çš„ä¸€ä¸ª `async block/fn` å†…éƒ¨ç©¶ç«Ÿç”Ÿæˆäº†ä»€ä¹ˆæ ·çš„ä»£ç ï¼Ÿæ¥çœ‹ä¸‹é¢è¿™ä¸ªç®€å•çš„ `async` å‡½æ•°ï¼š

```rust
async fn write_hello_file_async(name: &str) -> anyhow::Result<()> {
	let mut file = fs::File::create(name).await?;
	file.write_all(b"hello world").await?;

	Ok(())
}
```

é¦–å…ˆå®ƒåˆ›å»ºä¸€ä¸ªæ–‡ä»¶ï¼Œç„¶åå¾€è¿™ä¸ªæ–‡ä»¶é‡Œå†™å…¥ â€œhello world!â€ã€‚è¿™ä¸ªå‡½æ•°æœ‰ä¸¤ä¸ª awaitï¼Œåˆ›å»ºæ–‡ä»¶çš„æ—¶å€™ä¼šå¼‚æ­¥åˆ›å»ºï¼Œå†™å…¥æ–‡ä»¶çš„æ—¶å€™ä¼šå¼‚æ­¥å†™å…¥ã€‚æœ€ç»ˆï¼Œæ•´ä¸ªå‡½æ•°å¯¹å¤–è¿”å›ä¸€ä¸ª Futureã€‚

å…¶ä»–äººå¯ä»¥è¿™æ ·è°ƒç”¨ï¼š

```rust
write_hello_file_async("/tmp/hello").await?;
```

æˆ‘ä»¬çŸ¥é“ï¼Œ`executor` å¤„ç† Future æ—¶ï¼Œä¼šä¸æ–­åœ°è°ƒç”¨å®ƒçš„ `poll()` æ–¹æ³•ï¼Œäºæ˜¯ï¼Œä¸Šé¢é‚£å¥å®é™…ä¸Šç›¸å½“äºï¼š

```rust
match write_hello_file_async.poll(cx) {
	Poll::Ready(result) => return result,
	Poll::Pending => return Poll::Pending
}
```

è¿™æ˜¯å•ä¸ª await çš„å¤„ç†æ–¹æ³•ï¼Œé‚£æ›´åŠ å¤æ‚çš„ï¼Œä¸€ä¸ªå‡½æ•°ä¸­æœ‰è‹¥å¹²ä¸ª awaitï¼Œè¯¥æ€ä¹ˆå¤„ç†å‘¢ï¼Ÿä»¥å‰é¢`write_hello_file_async` å‡½æ•°çš„å†…éƒ¨å®ç°ä¸ºä¾‹ï¼Œæ˜¾ç„¶ï¼Œæˆ‘ä»¬åªæœ‰åœ¨å¤„ç†å®Œ `create()`ï¼Œæ‰èƒ½å¤„ç† `write_all()`ï¼Œæ‰€ä»¥ï¼Œåº”è¯¥æ˜¯ç±»ä¼¼è¿™æ ·çš„ä»£ç ï¼š

```rust
let fut = fs::File::create(name);
match fut.poll(cx) {
	Poll::Ready(Ok(file)) => {
		let fut = file.write_all(b"hello world");
		match fut.poll(cx) {
			Poll::Ready(result) => return result,
			Poll::Pending => return Poll::Pending
		}
	}
	Poll::Pending => return Poll::Pending	
}
```

ä½†æ˜¯ï¼Œå‰é¢è¯´è¿‡ï¼Œ`async` å‡½æ•°è¿”å›çš„æ˜¯ä¸€ä¸ª Futureï¼Œæ‰€ä»¥ï¼Œè¿˜éœ€è¦æŠŠè¿™æ ·çš„ä»£ç å°è£…åœ¨ä¸€ä¸ª Future çš„å®ç°é‡Œï¼Œå¯¹å¤–æä¾›å‡ºå»ã€‚å› æ­¤ï¼Œæˆ‘ä»¬éœ€è¦å®ç°ä¸€ä¸ªæ•°æ®ç»“æ„ï¼ŒæŠŠå†…éƒ¨çš„çŠ¶æ€ä¿å­˜èµ·æ¥ï¼Œå¹¶ä¸ºè¿™ä¸ªæ•°æ®ç»“æ„å®ç° Futureã€‚æ¯”å¦‚ï¼š

```rust
enum WriteHelloFile {
	// åˆå§‹é˜¶æ®µï¼Œç”¨æˆ·æä¾›æ–‡ä»¶å
	Init(String),
	// ç­‰å¾…æ–‡ä»¶åˆ›å»ºï¼Œæ­¤æ—¶éœ€è¦ä¿å­˜ Future ä»¥ä¾¿å¤šæ¬¡è°ƒç”¨
	// è¿™æ˜¯ä¼ªä»£ç ï¼Œimpl Future ä¸èƒ½ç”¨åœ¨è¿™é‡Œ
	AwaitingCreate(impl Future<Output=Result<fs::File, std::io::Error>>),
	// ç­‰å¾…æ–‡ä»¶å†™å…¥ï¼Œæ­¤æ—¶éœ€è¦ä¿å­˜ Future ä»¥ä¾¿å¤šæ¬¡è°ƒç”¨
	AwaitingWrite(impl Future<Output=Result<(), std::io::Error>>),
	// Future å¤„ç†å®Œæ¯•
	Done
}

impl WriteHelloFile {
	pub fn new(name: impl Into<String>) -> Self {
		Self::Init(name.into)
	}
}

impl Future for WriteHelloFile {
	type Output = Result<(), std::io::Error>;

	fn poll(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output> {
		todo!()
	}
}

fn write_hello_file_async(name: &str) -> WriteHelloFile {
	WriteHelloFile::new(name)
}
```

è¿™æ ·ï¼Œæˆ‘ä»¬å°±æŠŠåˆšæ‰çš„ `write_hello_file_async` å¼‚æ­¥å‡½æ•°ï¼Œè½¬åŒ–æˆäº†ä¸€ä¸ªè¿”å› `WriteHelloFile` Future çš„å‡½æ•°ã€‚æ¥çœ‹è¿™ä¸ª Future å¦‚ä½•å®ç°ï¼ˆè¯¦ç»†æ³¨é‡Šäº†ï¼‰ï¼š

```rust
impl Future for WriteHelloFile {
	type Output = Result<(), std::io::Error>;

	fn poll(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output> {
		let this = self.get_mut();
		loop {
			match this {
				// å¦‚æœçŠ¶æ€æ˜¯ Init, é‚£ä¹ˆå°±ç”Ÿæˆ create Future, å°†çŠ¶æ€åˆ‡æ¢åˆ° AwaitingCreate
				WriteHelloFile::Init(name) => {
					let fut = fs::File::create(name);
					*self = WriteHelloFile::AwaitingCreate(fut);
				}
				// å¦‚æœçŠ¶æ€æ˜¯ AwaitingCreate, é‚£ä¹ˆ poll create Future
				// å¦‚æœè¿”å› Poll::Ready(Ok(_)), é‚£ä¹ˆåˆ›å»º write Future
				// å¹¶æŠŠçŠ¶æ€åˆ‡æ¢åˆ° Awaiting
				WriteHelloFile::AwaitingCreate(fut) => match fut.poll(cx) {
					Poll::Ready(Ok(file)) => {
						let fut = file.write_all(b"hello world");
						*self = WritingHelloFile::AwaitingWrite(fut);
					}
					Poll::Ready(Err(e)) => {
						return Poll::Ready(Err(e))
					}
					Poll::Pending => return Poll:Pending
				},
				// å¦‚æœçŠ¶æ€æ˜¯ AwaitingWrite, é‚£ä¹ˆ poll write Future
				// å¦‚æœè¿”å› Poll::Ready(_), é‚£ä¹ˆçŠ¶æ€åˆ‡æ¢åˆ° Done, æ•´ä¸ª Future æ‰§è¡ŒæˆåŠŸ
				WriteHelloFile::AwaitingWrite(fut) => match fut.poll(cx) {
					Poll::Ready(result) => {
						*self = WriteHelloFile::Done;
						return Poll::Ready(result);
					}
					Poll::Pending => return Poll::Pending
				}
				// æ•´ä¸ª Future å·²ç»æ‰§è¡Œå®Œæ¯•
				WriteHelloFile::Done => return Poll::Ready(Ok(()))
			}
		}
	}
}
```

è¿™ä¸ª Future å®Œæ•´å®ç°çš„å†…éƒ¨ç»“æ„ ï¼Œå…¶å®å°±æ˜¯ä¸€ä¸ªçŠ¶æ€æœºçš„è¿ç§»ã€‚è¿™æ®µï¼ˆä¼ªï¼‰ä»£ç å’Œä¹‹å‰å¼‚æ­¥å‡½æ•°æ˜¯ç­‰ä»·çš„ï¼š

```rust
async fn write_hello_file_async(name: &str) -> anyhow::Result<()> {
	let mut file = fs::File::create(name).await?;
	file.write_all(b"hello world").await?;
	Ok(())
}
```

**Rust åœ¨ç¼–è¯‘ async fn æˆ–è€… async block æ—¶ï¼Œå°±ä¼šç”Ÿæˆç±»ä¼¼çš„çŠ¶æ€æœºçš„å®ç°**ã€‚ä½ å¯ä»¥çœ‹åˆ°ï¼Œçœ‹ä¼¼ç®€å•çš„å¼‚æ­¥å¤„ç†ï¼Œå†…éƒ¨éšè—äº†ä¸€å¥—å¹¶ä¸éš¾ç†è§£ã€ä½†æ˜¯å†™èµ·æ¥å¾ˆç”Ÿç¡¬å¾ˆå•°å—¦çš„çŠ¶æ€æœºç®¡ç†ä»£ç ã€‚

å¥½ææ˜ç™½è¿™ä¸ªé—®é¢˜ï¼Œå›åˆ° pin ã€‚åˆšæ‰æˆ‘ä»¬æ‰‹å†™çŠ¶æ€æœºä»£ç çš„è¿‡ç¨‹ï¼Œèƒ½å¸®ä½ ç†è§£ä¸ºä»€ä¹ˆä¼šéœ€è¦ `Pin` è¿™ä¸ªé—®é¢˜ã€‚

### ä¸ºä»€ä¹ˆéœ€è¦ Pin
åœ¨ä¸Šé¢å®ç° Future çš„çŠ¶æ€æœºä¸­ï¼Œæˆ‘ä»¬å¼•ç”¨äº† `file` è¿™æ ·ä¸€ä¸ªå±€éƒ¨å˜é‡ï¼š

```rust
WriteHelloFile::AwaitingCreate(fut) => match fut.poll(cx) {
	Poll::Ready(Ok(file)) => {
		let fut = file.write_all(b"hello world");
		*self = WritingHelloFile::AwaitingWrite(fut);
	}
	Poll::Ready(Err(e)) => return Poll::Ready(Err(e))
	Poll::Pending => return Poll::Pending
}
```

è¿™ä¸ªä»£ç æ˜¯ç”±é—®é¢˜çš„ï¼Œ`file` è¢« `fut` å¼•ç”¨ï¼Œä½† `file` ä¼šåœ¨è¿™ä¸ªä½œç”¨åŸŸè¢«ä¸¢å¼ƒï¼Œæ‰€ä»¥ï¼Œæˆ‘ä»¬éœ€è¦å°†å…¶ä¿å­˜åœ¨æ•°æ®ç»“æ„ä¸­ï¼š

```rust
enum WriteHelloFile {
	// åˆå§‹é˜¶æ®µï¼Œç”¨æˆ·æä¾›æ–‡ä»¶å
	Init(String),
	// ç­‰å¾…æ–‡ä»¶åˆ›å»ºï¼Œæ­¤æ—¶éœ€è¦ä¿å­˜ Future ä»¥ä¾¿å¤šæ¬¡è°ƒç”¨
	AwaitingCreate(impl Future<Output=Result<fs::File, std::io::Error>>),
	// ç­‰å¾…æ–‡ä»¶å†™å…¥ï¼Œæ­¤æ—¶éœ€è¦ä¿å­˜ Future ä»¥ä¾¿å¤šæ¬¡è°ƒç”¨
	AwaitingWrite(AwaitingWriteData),
	// Future å¤„ç†å®Œæ¯•
	Done
}

struct AwaitingWriteData {
	fut: impl Future<Output = Result<(), std::io::Error>>,
	file: fs::File
}
```

å¯ä»¥ç”Ÿæˆä¸€ä¸ª `AwaitingWriteData` æ•°æ®ç»“æ„ï¼ŒæŠŠ `file` å’Œ `fut` éƒ½æ”¾è¿›å»ï¼Œç„¶ååœ¨ `WriteHelloFile` ä¸­å¼•ç”¨å®ƒã€‚æ­¤æ—¶ï¼Œåœ¨åŒä¸€ä¸ªæ•°æ®ç»“æ„å†…éƒ¨ï¼Œ`fut` æŒ‡å‘äº†å¯¹ `file` çš„å¼•ç”¨ï¼Œè¿™æ ·çš„æ•°æ®ç»“æ„ï¼Œå«**è‡ªå¼•ç”¨ç»“æ„ï¼ˆSelf-Referential Structureï¼‰**ã€‚

è‡ªå¼•ç”¨ç»“æ„æœ‰ä¸€ä¸ªå¾ˆå¤§çš„é—®é¢˜æ˜¯ï¼šä¸€æ—¦å®ƒè¢«ç§»åŠ¨ï¼ŒåŸæœ¬çš„æŒ‡é’ˆå°±ä¼šæŒ‡å‘æ—§çš„åœ°å€ã€‚

![[Pasted image 20250119162217.png]]

æ‰€ä»¥éœ€è¦æœ‰æŸç§æœºåˆ¶æ¥ä¿è¯è¿™ç§æƒ…å†µä¸ä¼šå‘ç”Ÿã€‚`Pin` å°±æ˜¯ä¸ºè¿™ä¸ªç›®çš„è€Œè®¾è®¡çš„ä¸€ä¸ªæ•°æ®ç»“æ„ï¼Œæˆ‘ä»¬å¯ä»¥ Pin ä½æŒ‡å‘ä¸€ä¸ª Future çš„æŒ‡é’ˆï¼Œçœ‹æ–‡ç¨¿ä¸­ `Pin` çš„å£°æ˜ï¼š

```rust
pub struct Pin<P> {
	pointer: P
}

impl<P: Deref> Deref for Pin<P> {
	type Target = P::Target;

	fn deref(&self) -> &P::Target {
		Pin::get_ref(Pin::as_ref(self))
	}
}

impl<P: DerefMut<Target: Unpin>> DerefMut for Pin<P> {
	fn deref_mut(&mut self) -> &mut P::Target {
		Pin::get_mut(Pin::as_mut(self))
	}
}
```

Pin æ‹¿ä½çš„æ˜¯ä¸€**ä¸ªå¯ä»¥è§£å¼•ç”¨æˆ T çš„æŒ‡é’ˆç±»å‹ P**ï¼Œè€Œä¸æ˜¯ç›´æ¥æ‹¿åŸæœ¬çš„ç±»å‹ Tã€‚æ‰€ä»¥ï¼Œå¯¹äº Pin è€Œè¨€ï¼Œä½ çœ‹åˆ°çš„éƒ½æ˜¯ `Pin<Box<T>>`ã€`Pin<&mut T>`ï¼Œä½†ä¸ä¼šæ˜¯ `Pin<T>`ã€‚å› ä¸º Pin çš„ç›®çš„æ˜¯ï¼ŒæŠŠ T çš„å†…å­˜ä½ç½®é”ä½ï¼Œä»è€Œé¿å…ç§»åŠ¨åè‡ªå¼•ç”¨ç±»å‹å¸¦æ¥çš„å¼•ç”¨å¤±æ•ˆé—®é¢˜ã€‚

![[Pasted image 20250119162708.png]]

### è‡ªå¼•ç”¨æ•°æ®ç»“æ„
å½“ç„¶ï¼Œè‡ªå¼•ç”¨æ•°æ®ç»“æ„å¹¶éåªåœ¨å¼‚æ­¥ä»£ç é‡Œå‡ºç°ï¼Œåªä¸è¿‡å¼‚æ­¥ä»£ç åœ¨å†…éƒ¨ç”Ÿæˆç”¨çŠ¶æ€æœºè¡¨è¿°çš„ Future æ—¶ï¼Œå¾ˆå®¹æ˜“äº§ç”Ÿè‡ªå¼•ç”¨ç»“æ„ã€‚æˆ‘ä»¬çœ‹ä¸€ä¸ªå’Œ Future æ— å…³çš„ä¾‹å­ï¼š

```rust
#[derive(Debug)]
struct SelfReference {
	name: String,
	// åœ¨åˆå§‹åŒ–åæŒ‡å‘ name
	name_ptr: *const String
}

impl SelfReference {
	pub fn new(name: impl Into<String>) -> Self {
		SelfReference {
			name: name.into(),
			name_ptr: std::ptr::null()
		}
	}

	pub fn init(&mut self) {
		self.name_ptr = &self.name as *const String;
	}

	pub fn print_name(&self) {
		println!(
			"struct {:p} (name: {:p} name_ptr: {:p}), name: {}, name_ref: {}",	
			self,
			&self.name,
			self.name_ptr,
			self.name,
			// åœ¨è¯•ç”¨ ptr æ˜¯éœ€è¦ unsafe 
			// SAFETY: è¿™é‡Œ name_ptr æ½œåœ¨ä¸å®‰å…¨ï¼Œä¼šæŒ‡å‘æ—§çš„ä½ç½®
			unsafe { &*self.name_ptr }
		);
	}
}

fn main() {
	let data = move_creates_issues();
	println!("data: {:?}", data);
	// å¦‚æœæŠŠä¸‹é¢è¿™å¥æ³¨é‡Šæ‰ï¼Œç¨‹åºè¿è¡Œä¼šç›´æ¥ segment error
	// data.print_name();
	print!("\\n");
	mem_swap_creates_issue();
}

fn move_creates_issue() -> SelfReference {
	let mut data = SelfReference::new("Tyr");
	data.init();

	// ä¸ moveï¼Œä¸€åˆ‡æ­£å¸¸
	data.print_name();

	let data = move_it(data);

	// move ä¹‹åï¼Œname_ref æŒ‡å‘çš„ä½ç½®æ˜¯å·²ç»å¤±æ•ˆçš„åœ°å€
	// åªä¸è¿‡ç°åœ¨ move å‰çš„åœ°å€è¿˜æ²¡è¢«å›æ”¶æŒªä½œå®ƒç”¨
	data.print_name();
	data
}

fn mem_swap_creates_issue() {
	let mut data1 = SelfReference::new("Tyr");
	data1.init();

	let mut data2 = SelfReference::new("Lindsey");
	data2.init();

	data1.print_name();
	data2.print_name();

	std::mem::swap(&mut data1, &mut data2);
	data1.print_name();
	data2.print_name();
}

fn move_it(data: SelfReference) -> SelfReference {
	data
}
```

æˆ‘ä»¬åˆ›å»ºäº†ä¸€ä¸ªè‡ªå¼•ç”¨ç»“æ„ `SelfReference`ï¼Œå®ƒé‡Œé¢çš„ `name_ref` æŒ‡å‘äº† `name`ã€‚æ­£å¸¸ä½¿ç”¨å®ƒæ—¶ï¼Œæ²¡æœ‰ä»»ä½•é—®é¢˜ï¼Œä½†ä¸€æ—¦å¯¹è¿™ä¸ªç»“æ„åš move æ“ä½œï¼Œ`name_ref` æŒ‡å‘çš„ä½ç½®è¿˜ä¼šæ˜¯ move å‰ `name` çš„åœ°å€ï¼Œè¿™å°±å¼•å‘äº†é—®é¢˜ã€‚çœ‹ä¸‹å›¾ï¼š

![[Pasted image 20250120141149.png]]
åŒæ ·çš„ï¼Œå¦‚æœæˆ‘ä»¬ä½¿ç”¨ `std::mem:swap`ï¼Œä¹Ÿä¼šå‡ºç°ç±»ä¼¼çš„é—®é¢˜ï¼Œä¸€æ—¦ swapï¼Œä¸¤ä¸ªæ•°æ®çš„å†…å®¹äº¤æ¢ï¼Œç„¶è€Œï¼Œç”±äº `name_ref` æŒ‡å‘çš„åœ°å€è¿˜æ˜¯æ—§çš„ï¼Œæ‰€ä»¥æ•´ä¸ªæŒ‡é’ˆä½“ç³»éƒ½æ··ä¹±äº†ï¼š

![[Pasted image 20250120143600.png]]

ä½ ä¹Ÿè®¸ä¼šå¥‡æ€ªï¼Œä¸æ˜¯è¯´ move ä¹Ÿä¼šå‡ºé—®é¢˜ä¹ˆï¼Ÿä¸ºä»€ä¹ˆç¬¬äºŒè¡Œæ‰“å° `name_ref` è¿˜æ˜¯æŒ‡å‘äº† â€œTyrâ€ï¼Ÿè¿™æ˜¯å› ä¸º move åï¼Œä¹‹å‰çš„å†…å­˜å¤±æ•ˆï¼Œä½†æ˜¯å†…å­˜åœ°å€è¿˜æ²¡æœ‰è¢«æŒªä½œå®ƒç”¨ï¼Œæ‰€ä»¥è¿˜èƒ½æ­£å¸¸æ˜¾ç¤º â€œTyrâ€ã€‚ä½†è¿™æ ·çš„å†…å­˜è®¿é—®æ˜¯ä¸å®‰å…¨çš„ï¼Œå¦‚æœä½ æŠŠ `main` ä¸­è¿™å¥ä»£ç æ³¨é‡Šæ‰ï¼Œç¨‹åºå°±ä¼š crashï¼š

```rust
fn main() {
	let data = move_creates_issue();
	println!("data: {:?}", data);
	// å¦‚æœæŠŠä¸‹é¢è¿™å¥æ³¨é‡Šæ‰ï¼Œç¨‹åºè¿è¡Œä¼šç›´æ¥ segment error
	// data.print_name();
	print!("\\n");
	mem_swap_creates_issue();
}
```

æ‰€ä»¥ï¼ŒPin çš„å‡ºç°ï¼Œå¯¹è§£å†³è¿™ç±»é—®é¢˜å¾ˆå…³é”®ï¼Œå¦‚æœä½ è¯•å›¾ç§»åŠ¨è¢« Pin ä½çš„æ•°æ®ç»“æ„ï¼Œè¦ä¹ˆï¼Œç¼–è¯‘å™¨ä¼šé€šè¿‡ç¼–è¯‘é”™è¯¯é˜»æ­¢ä½ ï¼›è¦ä¹ˆï¼Œä½ å¼ºè¡Œä½¿ç”¨ unsafe Rustï¼Œè‡ªå·±è´Ÿè´£å…¶å®‰å…¨æ€§ã€‚æˆ‘ä»¬æ¥çœ‹ä½¿ç”¨ Pin åå¦‚ä½•é¿å…ç§»åŠ¨å¸¦æ¥çš„é—®é¢˜ï¼š

```rust
use std::{marker::PhantomData, pin::Pin};

#[derive(Debug)]
struct SelfReference {
	name: String,
	// åœ¨åˆå§‹åŒ–åæŒ‡å‘ name
	name_ptr: *const String,
	// PhantomPinned å ä½ç¬¦
	_marker: PhantomPinned
}

impl SelfReference {
	pub fn new(name: impl Into<String>) -> Self {
		SelfReference {
			name: name.into(),
			name_ptr: str::ptr::null(),
			_marker: PhantomPinned
		}
	}

	pub fn init(self: Pin<&mut Self>) {
		let name_ptr = &self.name as *const String;
		// SAFETY: è¿™é‡Œå¹¶ä¸ä¼šæŠŠä»»ä½•æ•°æ®ä» &mut SelfReference ä¸­ç§»èµ°
		let this = unsafe { self.get_unchecked_mut() };
		this.name_ptr = name_ptr;
	}

	pub fn print_name(self: Pin<&Self>) {
		println!(
			"struct {:p}: (name: {:p} name_ptr: {:p}), name: {}, name_ref: {}",
			self,
			&self.name,
			self.name_ptr,
			self.name,
			// åœ¨ä½¿ç”¨ ptr æ˜¯éœ€è¦ unsafe 
			// SAFETY: å› ä¸ºæ•°æ®ä¸ä¼šç§»åŠ¨ï¼Œæ‰€ä»¥è¿™é‡Œçš„ name_ptr æ˜¯å®‰å…¨çš„
			unsafe { &*self.name_ptr }
		);
	} 
}

fn main() {
	move_create_issue();
}

fn move_creates_issue() {
	let mut data = SelfReference::new("Tyr");
	let mut data = unsafe { Pin::new_unchecked(&mut data) };
	SelfReference::init(data.as_mut());

	// ä¸ move, ä¸€åˆ‡æ­£å¸¸
	data.as_ref().print_name();

	// ç°åœ¨åªèƒ½æ‹¿åˆ° pinned åçš„æ•°æ®ï¼Œæ‰€ä»¥ move ä¸äº†ä¹‹å‰
	move_pinned(data.as_mut());
	println!("{:?} ({:p}))", data, &data);

	// ä½ æ— æ³•æ‹¿å› Pin ä¹‹å‰çš„ SelfReference ç»“æ„ï¼Œæ‰€ä»¥è°ƒç”¨ä¸äº† move_it
	// move_it(data);
}

fn move_pinned(data: Pin<&mut SelfReference>) {
	println!("{:?} ({:p})", data, &data);
}

#[allow(dead_code)]
fn move_it(data: SelfReference) {
	println!("{:?} ({:p})", data, &data);
}
```

ç”±äºæ•°æ®ç»“æ„è¢«åŒ…è£¹åœ¨ Pin å†…éƒ¨ï¼Œæ‰€ä»¥åœ¨å‡½æ•°é—´ä¼ é€’æ—¶ï¼Œå˜åŒ–çš„åªæ˜¯æŒ‡å‘ `data` çš„ Pin:

![[Pasted image 20250120150740.png]]

### é‚£ä¹ˆï¼ŒUnpin æ˜¯åšä»€ä¹ˆçš„ï¼Ÿ
```rust
pub auto trait Unpin {}
```

Pin æ˜¯ä¸ºäº†è®©æŸä¸ªæ•°æ®ç»“æ„æ— æ³•åˆæ³•åœ°ç§»åŠ¨ï¼Œè€Œ Unpin åˆ™ç›¸å½“äºå£°æ˜æ•°æ®ç»“æ„æ˜¯å¯ä»¥ç§»åŠ¨çš„ï¼Œå®ƒçš„ä½œç”¨ç±»ä¼¼äº Send / Syncï¼Œé€šè¿‡ç±»å‹çº¦æŸæ¥å‘Šè¯‰ç¼–è¯‘å™¨å“ªäº›è¡Œä¸ºæ˜¯åˆæ³•çš„ã€å“ªäº›ä¸æ˜¯ã€‚

åœ¨ Rust ä¸­ï¼Œç»å¤§å¤šæ•°æ•°æ®ç»“æ„éƒ½æ˜¯å¯ä»¥ç§»åŠ¨çš„ï¼Œæ‰€ä»¥å®ƒä»¬éƒ½è‡ªåŠ¨å®ç°äº† Unpinã€‚å³ä¾¿è¿™äº›ç»“æ„è¢« Pin åŒ…è£¹ï¼Œå®ƒä»¬ä¾æ—§å¯ä»¥è¿›è¡Œç§»åŠ¨ï¼Œæ¯”å¦‚ï¼š

```rust
use std::mem;
use std::pin::Pin;

let mut string = "this".to_string();
let mut pinned_string = Pin::new(&mut string);

// We need a mutable reference to call `mem::replace`
// We can obtain such a reference by (implicitly) involing `Pin::deref_mut`
// but that is only possible because `String` implements `Unpin`
mem::replace(&mut *pinned_string, "other".to_string());
```

å½“æˆ‘ä»¬ä¸å¸Œæœ›ä¸€ä¸ªæ•°æ®ç»“æ„è¢«ç§»åŠ¨ï¼Œå¯ä»¥ä½¿ç”¨ !Unpinã€‚åœ¨ Rust é‡Œï¼Œå®ç°äº† !Unpin çš„ï¼Œé™¤äº†å†…éƒ¨ç»“æ„ï¼ˆæ¯”å¦‚ Futureï¼‰ï¼Œä¸»è¦å°±æ˜¯ `PhantomPinned`ï¼š

```rust
pub struct PhantomPinned;
impl !Unpin for PhantomPinned {}
```

æ‰€ä»¥ï¼Œ**å¦‚æœä½ å¸Œæœ›ä½ çš„æ•°æ®ç»“æ„ä¸èƒ½è¢«ç§»åŠ¨ï¼Œå¯ä»¥ä¸ºå…¶æ·»åŠ  `PhantomPinned` å­—æ®µæ¥éšå¼å£°æ˜ `!Unpin`**ã€‚

å½“æ•°æ®ç»“æ„æ»¡è¶³ Unpin æ—¶ï¼Œåˆ›å»º Pin ä»¥åŠä½¿ç”¨ Pinï¼ˆä¸»è¦æ˜¯ DerefMutï¼‰éƒ½å¯ä»¥ä½¿ç”¨å®‰å…¨æ¥å£ï¼Œå¦åˆ™ï¼Œéœ€è¦ä½¿ç”¨ unsafe æ¥å£ï¼š

```rust
// å¦‚æœå®ç°äº† Unpin, å¯ä»¥é€šè¿‡å®‰å…¨æ¥å£åˆ›å»ºå’Œè¿›è¡Œ DerefMut
impl<P: Deref<Target::Unpin>> Pin<P> {
	pub const fn new(pointer: P) -> Pin<P> {
		// SAFETY: the value pointed to is `Unpin`, and so has no requirements 
		// around pinning
		unsafe { Pin::new_unchecked(pointer) }
	}

	pub const fn into_inner(pin: Pin<P>) -> P {
		pin.pointer
	}
}

impl<P: DerefMut<Target: Unpin>> DerefMut for Pin<P> {
	fn deref_mut(&mut self) -> &mut P::Target {
		Pin::get_mut(Pin::as_mut(self))
	}
}

// å¦‚æœæ²¡æœ‰å®ç° Unpin, åªèƒ½é€šè¿‡ unsafe æ¥å£åˆ›å»ºï¼Œä¸èƒ½ä½¿ç”¨ DerefMut
impl<P: Deref> Pin<P> {
	pub const unsafe fn new_unchecked(pointer: P) -> Pin<P> {
		Pin {pointer}
	}

	pub const unsafe fn into_inner_unchecked(pin: Pin<P>) -> P {
		pin.pointer
	}
}
```

# é‡ç‚¹æ‘˜è¦
> [!tip] 
> åœ¨å®Œæˆã€Œç¬¬ä¸€å±‚ï¼šåŸæ–‡æ‘˜è¦ã€åé©¬ä¸Šå°±æ•´ç†ã€Œç¬¬äºŒå±‚ï¼šé‡ç‚¹æ‘˜è¦ã€ï¼Œè™½ç„¶éœ€è¦éµå¾ªã€Œä¸åŒçš„æ—¶é—´æ®µå®Œæˆä¸åŒå±‚çº§ã€çš„è§„åˆ™ï¼Œä½†æ˜¯åœ¨é˜…è¯»æˆ–æ•´ç†ç¬”è®°çš„å½“ä¸‹ï¼Œå¦‚æœè§‰å¾—æœ‰äº›å†…å®¹éœ€è¦é‡ç‚¹æ ‡æ³¨ï¼Œéœ€è¦ç¬¬ä¸€æ—¶é—´å°†ã€Œç¬¬ä¸€å±‚ã€å†…å®¹æ‹·è´åˆ°ã€Œç¬¬äºŒå±‚ã€è¿›è¡Œã€Œé‡ç‚¹æ ‡æ³¨ã€ï¼ŒåŒæ—¶å¦‚æœæœ‰å¿…è¦ä¹Ÿå¯ä»¥æ·»åŠ è‡ªå·±çš„ã€Œæ³¨é‡Šã€ï¼Œæ–¹ä¾¿è¿›è¡Œè¾…åŠ©ç†è§£

# é•¿é’ç¬”è®°
> [!tip]
>  å¸¸é’ç¬”è®°ï¼Œä¹Ÿç§°ä¸ºæ°¸ä¹…ç¬”è®°ã€‚å¦‚æœå½“å‰ç¬”è®°çš„é˜…è¯»è®©ä½ äº§ç”Ÿäº†æ–°çš„çµæ„Ÿï¼Œç«™åœ¨ã€ŒåŸå§‹ç´ æã€çš„åŸºç¡€ä¸Šå†™ä¸€ç¯‡æ–‡ç« ï¼Œç„¶åé€šè¿‡ã€ŒåŒå‘é“¾æ¥ã€å°†ç¬”è®°æ·»åŠ åˆ°ã€Œç¬¬ä¸‰å±‚ï¼šå¸¸é’ç¬”è®°ã€ä¸­

# é—ªå¿µ
> [!tip]
> è¿™ä¸€å±‚ä¸»è¦å­˜æ”¾é‚£äº›ã€Œçµå…‰ä¸€ç°ã€çš„å†…å®¹ï¼Œå½“é˜…è¯»ç¬”è®°çš„å½“ä¸‹çªç„¶æŸä¸€æ®µå†…å®¹äº§ç”Ÿäº†ä¸€äº›çµæ„Ÿï¼Œéšæ‰‹è®°å½•åœ¨ã€Œç¬¬å››å±‚ã€ï¼Œå¹¶è®¾ç½®å¥½æ ‡ç­¾ã€Œé—ªå¿µèƒ¶å›Šã€æ–¹ä¾¿å°†æ¥ç´¢å¼•

# å›å½’é—®é¢˜
> [!tip] 
> ä½¿ç”¨å‡ ä¸ªé—®é¢˜ï¼Œå°†æœ¬ç¬”è®°å†…å®¹æ ¸å¿ƒçŸ¥è¯†æç‚¼å‡ºæ¥