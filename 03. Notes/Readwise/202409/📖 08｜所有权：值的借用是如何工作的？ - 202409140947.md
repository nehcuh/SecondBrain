---
title: 📖 08｜所有权：值的借用是如何工作的？
createdAt: 2024-09-14 09:47
notebook: "[[🗂️ Rust 编程第一课]]"
allDay: 
startTime: 11:30
endTime: 12:30
date: 2024-09-14
project: 
area: 
resource: 
archived: 
tags:
  - "#readwise"
  - "#note/🍀"
links: 
due: 2024-09-14
nextReview: 2024-09-21
status: "#done"
---

# 原文摘要
> [!tip] 
> 将原始文章中的较为重要的信息「摘录」到笔记当中，对一些稍微重要的信息进行「加粗处理」（用一对 ** 包裹着内容），在未来「回看笔记」时快速理解第一层信息

虽然，单一所有权解决了其它语言中值被任意共享带来的问题，但也引发了一些不便。我们上一讲提到：**当你不希望值的所有权被转移，又因为没有实现 Copy trait 而无法使用 Copy 语义，怎么办？你可以“借用”数据**，也就是这一讲我们要继续介绍的 Borrow 语义。

## Borrow 语义

Borrow 语义允许一个值的所有权，在不发生转移的情况下，被其它上下文使用。，Borrow 语义通过引用语法（& 或者 &mut）来实现。**在 Rust 中，“借用”和“引用”是一个概念**，只不过在其他语言中引用的意义和 Rust 不同，所以 Rust 提出了新概念“借用”，便于区分。

**在其他语言中**，引用是一种别名，你可以简单理解成鲁迅之于周树人，**多个引用拥有对值的无差别的访问权限，本质上是共享了所有权**；而**在 Rust 下，所有的引用都只是借用了“临时使用权”，它并不破坏值的单一所有权约束**。因此**默认情况下，Rust 的借用都是只读的**。

## 只读借用/引用

本质上，引用是一个受控的指针，指向某个特定的类型。在学习其他语言的时候，你会注意到**函数传参有两种方式：传值（pass-by-value）和传引用（pass-by-reference）**。
![[Pasted image 20240914095058.png]]
**以 Java 为例**，给函数传一个整数，这是传值，和 Rust 里的 `Copy` 语义一致；而**给函数传一个对象，或者任何堆上的数据结构，Java 都会自动隐式地传引用**。刚才说过，**Java 的引用是对象的别名**，这也**导致随着程序的执行，同一块内存的引用到处都是**，不得不依赖 GC 进行内存回收。

但 Rust 没有传引用的概念，**Rust 所有的参数传递都是传值**，不管是 `Copy` 还是 `Move`。所以**在 Rust 中，你必须显式地把某个数据的引用，传给另一个函数**。Rust 的引用实现了 Copy trait，所以按照 Copy 语义，这个引用会被复制一份交给要调用的函数。对这个函数来说，它并不拥有数据本身，数据只是临时借给它使用，所有权还在原来的拥有者那里。**在 Rust 里，引用是一等公民，和其他数据类型地位相等。**

用上一讲有两处错误的代码来演示。

```rust
fn main() {
	let data = vec![1, 2, 3, 4];
	let data1 = data;
	println!("sum of data: {}", sum(data1));
	println!("data1: {:?}", data1); // error1
	println!("sum of data: {}", sum(data)); // error2
}

fn sum(data: Vec<u32>) -> u32 {
	data.iter().fold(0, |acc, x| acc + x)
}
```

我们把代码稍微改变一下，通过添加引用，让编译通过，并查看值和引用的地址：

```rust
fn main() {
	let data = vec![1, 2, 3, 4];
	let data1 = &data;

	// 值的地址是什么？引用的地址又是什么？
	println!("addr of value: {:p}({:p}), addr of data {:p}, data1: {:p}", &data, data1, &&data, &data1);
	println!("sum of data1: {}", sum(data1));

	// 堆上数据的地址是什么？ 
	println!(
		"addr of items: [{:p}, {:p}, {:p}, {:p}]", 
		&data[0], &data[1], &data[2], &data[3]
	);
}

fn sum(data: &Vec<u32>) -> u32 {
	// 值的地址会改变么？引用的地址会改变么？ 
	println!("addr of value: {:p}, addr of ref: {:p}", data, &data);
	data.iter().fold(0, |acc, x| acc + x)
}
```

在运行这段代码之前，你可以先思考一下，`data` 对应值的地址是否保持不变，而 `data1` 引用的地址，在传给 `sum()` 函数后，是否还指向同一个地址。

以下为运行结果：
```
addr of value: 0x16b619d20(0x16b619d20), addr of data: 0x16b619df8, data1: 0x16b619d38
addr of value: 0x16b619d20, addr of ref: 0x16b619c08
sum of data1: 10
addr of items: [0x600000e7c040, 0x600000e7c044, 0x600000e7c048, 0x600000e7c04c
```

需要注意的是，对 `&u32` 会自动解引用，因此在 `data.iter()` 后会自动进行 `u32` 的操作。

![[Pasted image 20240914104313.png]]
`data1`、`&data` 和传到 `sum()` 里的 `data1'` 都指向 `data` 本身，这个值的地址是固定的。但是它们引用的地址都是不同的，这印证了我们讲 `Copy` trait 的时候，介绍过只读引用实现了 `Copy` trait，也就意味着引用的赋值、传参都会产生新的浅拷贝。

虽然 `data` 有很多只读引用指向它，但**堆上的数据依旧只有 `data` 一个所有者，所以值的任意多个引用并不会影响所有权的唯一性**。

但我们马上就发现了新问题：**一旦 `data` 离开了作用域被释放，如果还有引用指向 `data`，岂不是造成我们想极力避免的使用已释放内存（use after free）这样的内存安全问题？怎么办呢？**

## 借用的生命周期及其约束

所以，我们对值的引用也要有约束，这个约束是：**借用不能超过（outlive）值的生存期**。在上面的代码中，`sum()` 函数处在 `main()` 函数下一层调用栈中，它结束之后 `main()` 函数还会继续执行，所以在 `main()` 函数中定义的 `data` 生命周期要比 `sum()` 中对 `data` 的引用要长，这样不会有任何问题。

但如果是这样的代码呢（**情况 1**）？

```rust
fn main() {
	let r = local_ref();
	println!("r: {:p}", r);
}

fn local_ref<'a>() -> &'a i32 {
	let a = 42;
	&a
}
```

显然，生命周期更长的 `main()` 函数变量 `r` ，引用了生命周期更短的 `local_ref()` 函数里的局部变量，这违背了有关引用的约束，所以 Rust 不允许这样的代码编译通过。

那么，如果我们在堆内存中，使用栈内存的引用，可以么？根据过去的开发经验，你也许会脱口而出：不行！因为堆内存的生命周期显然比栈内存要更长更灵活，这样做内存不安全。

我们写段代码试试看，把一个本地变量的引用存入一个可变数组中。从基础知识的学习中我们知道，可变数组存放在堆上，栈上只有一个胖指针指向它，所以这是一个典型的把栈上变量的引用存在堆上的例子（情况 2）：

```rust
fn main() {
	let mut data: Vec<&u32> = Vec::new();
	let v = 42;
	data.push(&v);
	println!("data: {:?}", data);
}
```

竟然编译通过，怎么回事？我们变换一下，看看还能编译不（**情况 3**），又无法通过了！

```rust
fn main() {
	let mut data: Vec<&u32> = Vec::new();
	push_local_ref(&mut data);
	println!("data: {:?}", data);
}

fn push_local(data: &mut Vec<&u32>) {
	let v = 42;
	data.push(&v);
}
```

这三段代码看似错综复杂，但如果抓住了一个**核心要素“在一个作用域下，同一时刻，一个值只能有一个所有者”**，你会发现，其实很简单。

堆变量的生命周期不具备任意长短的灵活性，因为堆上内存的生死存亡，跟栈上的所有者牢牢绑定。而栈上内存的生命周期，又跟栈的生命周期相关，所以我们**核心只需要关心调用栈的生命周期**。

为什么情况 1 和情况 3 的代码无法编译通过了，因为它们引用了生命周期更短的值，而情况 2 的代码虽然在堆内存里引用栈内存，但生命周期是相同的，所以没有问题。

![[Pasted image 20240914114608.png]]
## 可变借用/引用

在没有引入可变借用之前，因为一个值同一时刻只有一个所有者，所以如果要修改这个值，只能通过唯一的所有者进行。但是，如果允许借用改变值本身，会带来新的问题。

我们先看第一种情况，**多个可变引用共存**：

```rust
fn main() {
	let mut data = vec![1, 2, 3];

	for item in data.iter_mut() {
		data.push(*item + 1);
	}
}
```

这段代码在遍历可变数组 `data` 的过程中，还往 `data` 里添加新的数据，这是很危险的动作，因为它破坏了**循环的不变性**（loop invariant），容易导致死循环甚至系统崩溃。所以，**在同一个作用域下有多个可变引用，是不安全的**。

由于 Rust 编译器阻止了这种情况，上述代码会编译出错。我们可以用 Python 来体验一下多个可变引用可能带来的死循环：

```python
if __name__ == "__main__":
    data = [1, 2]
    for item in data:
        data.append(item + 1)
        print(item)
    # unreachable code
    print(data)
```

同一个上下文中多个可变引用是不安全的，那如果**同时有一个可变引用和若干个只读引用**，会有问题吗？我们再看一段代码：

```rust
fn main() {
	let mut data = vec![1, 2, 3];
	let data1 = vec![&data[0]];
	println!("data[0]: {:p}", &data[0]);

	for i in 0..100 {
		data.push(i);
	}

	println!("data[0]: {:p}", &data[0]);
	println!("boxed: {:p}", &data1);
}
```

这段代码中，`data` 的只读引用和可变引用共存，似乎没有什么影响，因为 `data1` 引用的元素并没有任何改动。如果你仔细推敲，就会发现这里有内存不安全的潜在操作：如果继续添加元素，堆上的数据预留的空间不够了，就会重新分配一片足够大的内存，把之前的值拷过来，然后释放旧的内存。这样就会让 `data1` 中保存的 `&data[0]` 引用失效，导致内存安全问题。

## Rust 的限制

多个可变引用共存、可变引用和只读引用共存这两种问题，通过 GC 等自动内存管理方案可以避免第二种，但是第一个问题 GC 也无济于事。所以为了保证内存安全，Rust 对可变引用的使用也做了严格的约束：
- **在一个作用域内，仅允许一个活跃的可变引用**。所谓活跃，就是真正被使用来修改数据的可变引用，**如果只是定义了，却没有使用或者当作只读引用使用，不算活跃**。
- 在一个作用域内，**活跃的可变引用（写）和只读引用（读）是互斥的**，不能同时存在。
这个约束你是不是觉得看上去似曾相识？对，它和**数据在并发下的读写访问（比如 RwLock）规则非常类似**，你可以类比学习。

![[Pasted image 20240914121519.png]]

# 重点摘要
> [!tip] 
> 在完成「第一层：原文摘要」后马上就整理「第二层：重点摘要」，虽然需要遵循「不同的时间段完成不同层级」的规则，但是在阅读或整理笔记的当下，如果觉得有些内容需要重点标注，需要第一时间将「第一层」内容拷贝到「第二层」进行「重点标注」，同时如果有必要也可以添加自己的「注释」，方便进行辅助理解

# 长青笔记
> [!tip]
>  常青笔记，也称为永久笔记。如果当前笔记的阅读让你产生了新的灵感，站在「原始素材」的基础上写一篇文章，然后通过「双向链接」将笔记添加到「第三层：常青笔记」中

单一所有权引入新的问题，如果不想讲数据所有权转交，但是对方又需要使用的数据的场景，此时可以使用借用的概念。抽丝剥茧，不可变借用的值只有一个所有者，但是如果值的作用域结束，需要释放的时候，其他借用需要怎么办， 此时就引入了 “生命周期” 的概念，借用不能超过说借用的值的生命周期，以此避免出现悬垂引用的问题。有时候不仅仅是不可变借用，还会有需要可变借用的场景，当引入可变借用后，可能出现一个作用域内同时出现多个可变借用或者一个活跃的可变借用与多个不可变借用，后一种场景在其他语言通过 GC 解决，前一种场景 GC 无法解决。Rust 制定了相应的原则，同一时刻，同一作用域下只能有一个活跃的可变借用。

# 闪念
> [!tip]
> 这一层主要存放那些「灵光一现」的内容，当阅读笔记的当下突然某一段内容产生了一些灵感，随手记录在「第四层」，并设置好标签「闪念胶囊」方便将来索引

# 回归问题
> [!tip] 
> 使用几个问题，将本笔记内容核心知识提炼出来



