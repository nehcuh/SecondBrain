---
title: 📖 07｜所有权：值的生杀大权到底在谁手上？
createdAt: 2024-09-07 14:24
notebook: "[[🗂️ Rust 编程第一课]]"
allDay: 
startTime: 14:10
endTime: 14:49
date: 2024-09-07
project: 
area: 
resource: 
archived: 
tags:
  - "#readwise"
  - "#note/🍀"
links: 
due: 2024-09-07
nextReview: 2024-09-14
status: "#done"
---

# 原文摘要
> [!tip] 
> 将原始文章中的较为重要的信息「摘录」到笔记当中，对一些稍微重要的信息进行「加粗处理」（用一对 ** 包裹着内容），在未来「回看笔记」时快速理解第一层信息

这一讲我们换个思路，从**一个变量使用堆栈的行为**开始，探究 Rust 设计所有权和生命周期的用意，帮你从根上解决这些编译问题。

## 变量在函数调用时发生了什么
看这段代码, `main()` 函数中定义了一个动态数组 `data` 和一个值 `v`，然后将其传递给函数 `find_pos`, 在 `data` 中查找 `v` 是否存在，存在则返回 `v` 在 `data` 中的下标，不存在返回 `None`:

```rust
fn main() {
	let data = vec![10, 42, 9, 8];
	let v = 42;

	if let Some(pos) = find_pos(data, v) {
		println!("Found {} at pos {}", v, pos);
	}
}

fn find_pos(data: Vec<u32>, v: u32) -> Option<usize> {
	for(pos, item) in data.iter().enumerate() { 
		if *item == v { 
			return Some(pos); 
		}
	} 
	None
}
```

这段代码不难理解，要再强调一下的是，**动态数组因为大小在编译期无法确定，所以放在堆上**，并且在栈上有一个包含了长度和容量的胖指针指向堆上的内存。

在调用 `find_pos()` 时, `main()` 函数中的局部变量 `data` 和 `v` 作为参数传递给了 `find_pos()`，所以它们会被放在 `find_pos()` 的参数区。

![[Pasted image 20240907142938.png]]

按照**大多数编程语言的做法，现在堆上的内存就有了两个引用**。不光如此，我们每把 data 作为参数传递一次，堆上的内存就会多一次引用。但是，**这些引用究竟会做什么操作，我们不得而知**，也无从限制；而且**堆上的内存究竟什么时候能释放，尤其在多个调用栈引用时，很难厘清**，取决于最后一个引用什么时候结束。所以，这样一个看似简单的函数调用，给内存管理带来了极大麻烦。

对于堆内存多次引用的问题，我们先来看大多数语言的方案：
- C/C++ 要求开发者手工处理
- Java 等语言使用追踪式 GC：通过定期扫描堆上数据还有没有人引用，来替开发者管理堆内存，GC 带来的 STW 问题让语言的使用场景受限，性能损耗也不小
- ObjC/Swift 使用自动引用计数（ARC）：在编译时自动添加维护引用计数的代码，减轻开发者维护堆内存的负担，它也会有不小的运行时性能损耗

## Rust 解决思路
在 Rust 以前，引用是一种随意的、可以隐式产生的、对权限没有界定的行为，比如 C 里到处乱飞的指针、Java 中随处可见的按引用传参，它们可读可写，权限极大。而 **Rust 决定限制开发者随意引用的行为**。谁真正拥有数据或者说值的生杀大权，这种权利可以共享还是需要独占？

## 所有权和 `move` 语义
一个值最好只有一个拥有者，因为所有权共享，势必会带来使用和释放上的不明确，走回追踪式 GC 或者 ARC 的老路。那么如何保证独占呢？对此，Rust 给出了如下规则：
- 一个值只能被一个变量所拥有，这个变量被称为所有者
- 一个值同一时刻只能有一个所有者
- 当所有者离开作用域，其拥有的值被丢弃
在这三条所有权规则的约束下，我们看开头的引用问题是如何解决的：

![[Pasted image 20240907143354.png]]

原先 `main()` 函数中的 `data`，被移动到 `find_pos()` 后，就失效了，编译器会保证 `main()` 函数随后的代码无法访问这个变量，这样，就确保了堆上的内存依旧只有唯一的引用。这里的 `v` 实现了 `Copy` trait，会按位进行浅拷贝。

可以看到，**所有权规则，解决了谁真正拥有数据的生杀大权问题**，让堆上数据的多重引用不复存在，这是它最大的优势。但是，这也会让代码变复杂，尤其是**一些只存储在栈上的简单数据，如果要避免所有权转移之后不能访问的情况，我们就需要手动复制**，会非常麻烦，效率也不高。Rust 考虑到了这一点，提供了两种方案：
1. 如果你不希望值的所有权被转移，在 `Move` 语义外，Rust 提供了 `Copy` 语义。如果一个数据结构实现了 `Copy` trait，那么它就会使用 `Copy` 语义。这样，在你**赋值或者传参时，值会自动按位拷贝（浅拷贝）**。
2. 如果你**不希望值的所有权被转移，又无法使用 `Copy` 语义，那你可以“借用”数据**，我们下一讲会详细讨论“借用”。

## `Copy` 语义和 `Copy` trait
符合 `Copy` 语义的类型，在你赋值或者传参时，值会自动按位拷贝。这句话不难理解，那在 Rust 中是具体怎么实现的呢？当你要移动一个值，如果值的类型实现了 `Copy` trait，就会自动使用 `Copy` 语义进行拷贝，否则使用 `Move` 语义进行移动。

好，回归正文，那在 Rust 中，什么数据结构实现了 `Copy` trait 呢？ 你可以通过下面的代码快速验证一个数据结构是否实现了 `Copy` trait：

```rust
fn is_copy<T: Copy>() {}

fn types_impl_copy_trait() { 
	is_copy::<bool>(); 
	is_copy::<char>(); 
	// all iXX and uXX, usize/isize, fXX implement Copy trait 
	is_copy::<i8>(); 
	is_copy::<u64>(); 
	is_copy::<i64>(); 
	is_copy::<usize>(); 
	// function (actually a pointer) is Copy 
	is_copy::<fn()>(); 
	// raw pointer is Copy 
	is_copy::<*const String>(); 
	is_copy::<*mut String>(); 
	// immutable reference is Copy 
	is_copy::<&[Vec<u8>]>(); 
	is_copy::<&String>(); 
	// array/tuple with values which is Copy is Copy 
	is_copy::<[u8; 4]>(); 
	is_copy::<(&str, &str)>(); 
} 

fn types_not_impl_copy_trait() { 
	// unsized or dynamic sized type is not Copy 
	is_copy::<str>(); 
	is_copy::<[u8]>(); 
	is_copy::<Vec<u8>>(); 
	is_copy::<String>(); 
	// mutable reference is not Copy 
	is_copy::<&mut String>(); 
	// array / tuple with values that not Copy is not Copy 
	is_copy::<[Vec<u8>; 4]>(); 
	is_copy::<(String, u32)>(); 
} 

fn main() { 
	types_impl_copy_trait(); 
	types_not_impl_copy_trait(); 
}
```

- 原生类型，包括函数、不可变引用和裸指针实现了 Copy
- 数组和元组，如果其内部的数据结构实现了 Copy，那么它们也实现了 Copy
- 可变引用没有实现 Copy
- 非固定大小的数据结构，没有实现 Copy。

## 小结
- 所有权：一个值只能被一个变量所拥有，且同一时刻只能有一个所有者，当所有者离开作用域，其拥有的值被丢弃，内存得到释放。
- `Move` 语义：赋值或者传参会导致值 `Move`，所有权被转移，一旦所有权转移，之前的变量就不能访问。
- `Copy` 语义：如果值实现了 `Copy` trait，那么赋值或传参会使用 `Copy` 语义，相应的值会被按位拷贝（浅拷贝），产生新的值。

# 重点摘要
> [!tip] 
> 在完成「第一层：原文摘要」后马上就整理「第二层：重点摘要」，虽然需要遵循「不同的时间段完成不同层级」的规则，但是在阅读或整理笔记的当下，如果觉得有些内容需要重点标注，需要第一时间将「第一层」内容拷贝到「第二层」进行「重点标注」，同时如果有必要也可以添加自己的「注释」，方便进行辅助理解

# 长青笔记
> [!tip]
>  常青笔记，也称为永久笔记。如果当前笔记的阅读让你产生了新的灵感，站在「原始素材」的基础上写一篇文章，然后通过「双向链接」将笔记添加到「第三层：常青笔记」中

从函数调用传参开始，对引用进行论述，其他语言由于引用被乱用，导致数据混乱，不同的引用会做什么操作，什么时候内存被释放，很难追踪。相比其他编程语言的做法，Rust 引入了所有权规则，一个值最好最有一个所有者，这里引入了 `Move` 语义。同时，为了避免引入所有权规则导致的不变，譬如栈上数据，所有权转移后无法访问的问题，Rust 引入了 `Copy` 语义，当进行赋值或者传参时，如果值实现了 `Copy` 语义，就会使用 `Copy` 语义。

# 闪念
> [!tip]
> 这一层主要存放那些「灵光一现」的内容，当阅读笔记的当下突然某一段内容产生了一些灵感，随手记录在「第四层」，并设置好标签「闪念胶囊」方便将来索引

定分止争，为了避免出现各路使用同一个值的混乱场景，按照最小权限的原则进行设置，然后在最小化权限情况下，考虑更多场景，从而引入 `Copy` 语义等。

# 回归问题
> [!tip] 
> 使用几个问题，将本笔记内容核心知识提炼出来

1. 实现 `find_pos`, 传参为 `Vec` 与 `u32`, 根据传参在内存的流动，说明 Rust 管理内存的思路。