---
title: ğŸ“– 35ï½œå®æ“é¡¹ç›®ï¼šå¦‚ä½•å®ç°ä¸€ä¸ªåŸºæœ¬çš„MPSC channelï¼Ÿ
createdAt: 2024-12-15 17:52
notebook: "[[ğŸ—ï¸ Rust ç¼–ç¨‹ç¬¬ä¸€è¯¾]]"
allDay: 
startTime: 
endTime: 
date: 2024-12-15
project: 
area: 
resource: 
archived: 
tags:
  - "#note/ğŸŒ±"
  - "#readwise"
links: 
due: 2024-12-15
nextReview: 2024-12-22
status: "#processing"
---

# åŸæ–‡æ‘˜è¦
> [!tip] 
> å°†åŸå§‹æ–‡ç« ä¸­çš„è¾ƒä¸ºé‡è¦çš„ä¿¡æ¯ã€Œæ‘˜å½•ã€åˆ°ç¬”è®°å½“ä¸­ï¼Œå¯¹ä¸€äº›ç¨å¾®é‡è¦çš„ä¿¡æ¯è¿›è¡Œã€ŒåŠ ç²—å¤„ç†ã€ï¼ˆç”¨ä¸€å¯¹Â ** åŒ…è£¹ç€å†…å®¹ï¼‰ï¼Œåœ¨æœªæ¥ã€Œå›çœ‹ç¬”è®°ã€æ—¶å¿«é€Ÿç†è§£ç¬¬ä¸€å±‚ä¿¡æ¯

å¥½ï¼Œæ¥çœ‹çœ‹ä»Šå¤©è¦å®ç°çš„ MPSC channel çš„åŸºæœ¬åŠŸèƒ½ã€‚ä¸ºäº†ç®€ä¾¿èµ·è§ï¼Œæˆ‘ä»¬åªå…³å¿ƒ unbounded MPSC channelã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œå½“é˜Ÿåˆ—å®¹é‡ä¸å¤Ÿæ—¶ï¼Œä¼šè‡ªåŠ¨æ‰©å®¹ï¼Œæ‰€ä»¥ï¼Œ**ä»»ä½•æ—¶å€™ç”Ÿäº§è€…å†™å…¥æ•°æ®éƒ½ä¸ä¼šè¢«é˜»å¡ï¼Œä½†æ˜¯å½“é˜Ÿåˆ—ä¸­æ²¡æœ‰æ•°æ®æ—¶ï¼Œæ¶ˆè´¹è€…ä¼šè¢«é˜»å¡**ï¼š

![[Pasted image 20241215175324.png]]
## æµ‹è¯•é©±åŠ¨çš„è®¾è®¡
ä¹‹å‰æˆ‘ä»¬ä¼šä»éœ€æ±‚çš„è§’åº¦æ¥è®¾è®¡æ¥å£å’Œæ•°æ®ç»“æ„ï¼Œä»Šå¤©æˆ‘ä»¬å°±æ¢ç§æ–¹å¼ï¼Œå®Œå…¨ç«™åœ¨ä½¿ç”¨è€…çš„è§’åº¦ï¼Œç”¨ä½¿ç”¨å®ä¾‹ï¼ˆæµ‹è¯•ï¼‰æ¥é©±åŠ¨æ¥å£å’Œæ•°æ®ç»“æ„çš„è®¾è®¡ã€‚

### éœ€æ±‚ 1
è¦å®ç°åˆšæ‰è¯´çš„ MPSC channelï¼Œéƒ½æœ‰ä»€ä¹ˆéœ€æ±‚å‘¢ï¼Ÿé¦–å…ˆï¼Œç”Ÿäº§è€…å¯ä»¥äº§ç”Ÿæ•°æ®ï¼Œæ¶ˆè´¹è€…èƒ½å¤Ÿæ¶ˆè´¹äº§ç”Ÿå‡ºæ¥çš„æ•°æ®ï¼Œä¹Ÿå°±æ˜¯åŸºæœ¬çš„ `send/recv`ï¼Œæˆ‘ä»¬ä»¥ä¸‹é¢è¿™ä¸ªå•å…ƒæµ‹è¯• 1 æ¥æè¿°è¿™ä¸ªéœ€æ±‚ï¼š

```rust
#[test]
fn channel_should_work() {
	let (mut s, mut r) = unbounded();
	s.send("hello world".to_string()).unwrap();
	let msg = r.recv().unwrap();
	assert_eq!(msg, "hello world");
}
```

è¿™é‡Œï¼Œé€šè¿‡ `unbounded()` æ–¹æ³•ï¼Œ å¯ä»¥åˆ›å»ºä¸€ä¸ª `sender` å’Œä¸€ä¸ª `receiver`ï¼Œ`sender` æœ‰ `send()` æ–¹æ³•ï¼Œå¯ä»¥å‘é€æ•°æ®ï¼Œ`receiver` æœ‰ `recv()` æ–¹æ³•ï¼Œå¯ä»¥æ¥å—æ•°æ®ã€‚æ•´ä½“çš„æ¥å£ï¼Œæˆ‘ä»¬è®¾è®¡å’Œ `std::sync::mpsc` ä¿æŒä¸€è‡´ï¼Œé¿å…ä½¿ç”¨è€…ä½¿ç”¨ä¸Šçš„å¿ƒæ™ºè´Ÿæ‹…ã€‚

ä¸ºäº†å®ç°è¿™æ ·ä¸€ä¸ªæ¥å£ï¼Œéœ€è¦ä»€ä¹ˆæ ·çš„æ•°æ®ç»“æ„å‘¢ï¼Ÿç”Ÿäº§è€…å’Œæ¶ˆè´¹è€…ä¹‹é—´ä¼šå…±äº«ä¸€ä¸ªé˜Ÿåˆ—ï¼Œå¯ä»¥ç”¨ `VecDeque`ã€‚æ˜¾ç„¶ï¼Œè¿™ä¸ªé˜Ÿåˆ—åœ¨æ’å…¥å’Œå–å‡ºæ•°æ®æ—¶éœ€è¦äº’æ–¥ï¼Œæ‰€ä»¥éœ€è¦ç”¨ `Mutex` æ¥ä¿æŠ¤å®ƒã€‚æ‰€ä»¥ï¼Œæˆ‘ä»¬å¤§æ¦‚å¯ä»¥å¾—åˆ°è¿™æ ·ä¸€ä¸ªç»“æ„ï¼š

```rust
struct Shared<T> {
	queue: Mutex<VecDeque<T>>
}

pub struct Sender<T> {
	queue: Arc<Shared<T>>
}

pub struct Receiver<T> {
	queue: Arc<Shared<T>>
}
```

### éœ€æ±‚ 2
ç”±äºéœ€è¦çš„æ˜¯ MPSCï¼Œæ‰€ä»¥ï¼Œæˆ‘ä»¬å…è®¸å¤šä¸ª sender å¾€ channel é‡Œå‘é€æ•°æ®ï¼š

```rust
#[test]
fn mutiple_senders_should_work() {
	let (mut s, mut r) = unbounded();
	let mut s1 = s.clone();
	let mut s2 = s.clone();

	let t = thread::spawn(move || {
		s.send(1).unwrap();	
	});

	let t1 = thread::spawn(move || {
		s1.send(2).unwrap();	
	});

	let t2 = thread::spawn(move || {
		s2.send(3).unwrap();	
	});

	for handle in [t, t1, t2] {
		handle.join().unwrap();	
	}

	let mut result = [r.recv().unwrap(), r.recv().unwrap(), r.recv().unwrap()]; 
	// åœ¨è¿™ä¸ªæµ‹è¯•é‡Œï¼Œæ•°æ®åˆ°è¾¾çš„é¡ºåºæ˜¯ä¸ç¡®å®šçš„ï¼Œæ‰€ä»¥æˆ‘ä»¬æ’ä¸ªåºå† assert 
	result.sort(); 

	assert_eq!(result, [1, 2, 3]);
}
```

è¿™ä¸ªéœ€æ±‚ï¼Œåˆšæ‰çš„æ•°æ®ç»“æ„å°±å¯ä»¥æ»¡è¶³ï¼Œåªæ˜¯ `Sender` éœ€è¦å®ç° `Clone` traitã€‚ä¸è¿‡æˆ‘ä»¬åœ¨å†™è¿™ä¸ªæµ‹è¯•çš„æ—¶å€™ç¨å¾®æœ‰äº›åˆ«æ‰­ï¼Œå› ä¸ºè¿™ä¸€è¡Œæœ‰ä¸æ–­é‡å¤çš„ä»£ç ï¼š

```rust
let mut result = [r.recv().unwrap(), r.recv().unwrap(), r.recv().unwrap()];
```

æ‰€ä»¥ï¼Œå½“å†™ä¸‹è¿™ä¸ªæµ‹è¯•çš„æ—¶å€™ï¼Œä¹Ÿè®¸ä¼šæƒ³ï¼Œæˆ‘ä»¬å¯å¦æä¾› `Iterator` çš„å®ç°ï¼Ÿ

### éœ€æ±‚ 3
æ¥ä¸‹æ¥è€ƒè™‘å½“é˜Ÿåˆ—ç©ºçš„æ—¶å€™ï¼Œreceiver æ‰€åœ¨çš„çº¿ç¨‹ä¼šè¢«é˜»å¡è¿™ä¸ªéœ€æ±‚ã€‚è¿™å¹¶ä¸ç®€å•ï¼Œæˆ‘ä»¬æ²¡æœ‰æ¯”è¾ƒç›´è§‚çš„æ–¹å¼æ¥æ£€æµ‹çº¿ç¨‹çš„çŠ¶æ€ã€‚

ä¸è¿‡ï¼Œ**æˆ‘ä»¬å¯ä»¥é€šè¿‡æ£€æµ‹â€œçº¿ç¨‹æ˜¯å¦é€€å‡ºâ€æ¥é—´æ¥åˆ¤æ–­çº¿ç¨‹æ˜¯å¦è¢«é˜»å¡**ã€‚ç†ç”±å¾ˆç®€å•ï¼Œå¦‚æœçº¿ç¨‹æ²¡æœ‰ç»§ç»­å·¥ä½œï¼Œåˆæ²¡æœ‰é€€å‡ºï¼Œé‚£ä¹ˆä¸€å®šè¢«é˜»å¡ä½äº†ã€‚é˜»å¡ä½ä¹‹åï¼Œæˆ‘ä»¬ç»§ç»­å‘é€æ•°æ®ï¼Œæ¶ˆè´¹è€…æ‰€åœ¨çš„çº¿ç¨‹ä¼šè¢«å”¤é†’ï¼Œç»§ç»­å·¥ä½œï¼Œæ‰€ä»¥æœ€ç»ˆé˜Ÿåˆ—é•¿åº¦åº”è¯¥ä¸º 0ã€‚

```rust
#[test]
fn receiver_should_be_blocked_when_nothing_to_read() {
	let (mut s, r) = unbounded();
	let mut s1 = s.clone();

	thread::spawn(move || {
		for idx, i in r.into_iter().enumerate() {
			// å¦‚æœè¯»åˆ°æ•°æ®ï¼Œç¡®ä¿å®ƒå’Œå‘é€çš„æ•°æ®ä¸€è‡´
			assert_eq!(idx, i);	
		}
		// è¯»ä¸åˆ°åº”è¯¥ä¼‘çœ ï¼Œæ‰€ä»¥ä¸ä¼šæ‰§è¡Œåˆ°è¿™ä¸€å¥ï¼Œæ‰§è¡Œåˆ°è¿™ä¸€å¥è¯´æ˜é€»è¾‘å‡ºé”™
		assert!(false);
    });

	thread::spawn(move || {
		for i in 0..100usize {
			s.send(i).unwrap();
		}
	});

	// 1ms è¶³å¤Ÿè®©ç”Ÿäº§è€…å‘é€å®Œ 100 ä¸ªæ¶ˆæ¯ï¼Œæ¶ˆè´¹è€…æ¶ˆè´¹å®Œ 100 ä¸ªæ¶ˆæ¯å¹¶é˜»å¡
	thread::sleep(Duration::from_millis(1));

	// å†æ¬¡å‘é€æ•°æ®ï¼Œå”¤é†’æ¶ˆè´¹è€…
	for i in 100..200usize {
		s1.send(i).unwrap();	
	}

	// ç•™ç‚¹æ—¶é—´è®© receiver å¤„ç†
	thread::sleep(Duration::from_millis(1));

	// å¦‚æœ receiver è¢«æ­£å¸¸å”¤é†’ï¼Œé‚£ä¹ˆé˜Ÿåˆ—é‡Œçš„æ•°æ®ä¼šéƒ½è¢«è¯»å®Œ
	assert_eq!(s1.total_queued_items(), 0);
}
```

è¿™ä¸ªæµ‹è¯•ä»£ç ä¸­ï¼Œ æˆ‘ä»¬å‡å®š receiver å®ç°äº† `Iterator`ï¼Œ è¿˜å‡å®š sender æä¾›äº†ä¸€ä¸ªæ–¹æ³• `total_queued_items()`ã€‚ è¿™äº›å¯ä»¥åœ¨å®ç°çš„æ—¶å€™å†å¤„ç†ã€‚

å¥½ï¼Œå¦‚æœè¦èƒ½æ”¯æŒé˜Ÿåˆ—ä¸ºç©ºæ—¶é˜»å¡ï¼Œæˆ‘ä»¬éœ€è¦ä½¿ç”¨ `Condvar`ã€‚ æ‰€ä»¥ `Shared<T>`Â éœ€è¦ä¿®æ”¹ä¸€ä¸‹ï¼š

```rust
struct Shared<T> {
	queue: Mutex<VecDeque<T>>,
	available: Condvar
}
```

è¿™æ ·å½“å®ç° `Receiver` çš„ `recv()` æ–¹æ³•åï¼Œæˆ‘ä»¬å¯ä»¥åœ¨è¯»ä¸åˆ°æ•°æ®æ—¶é˜»å¡çº¿ç¨‹ï¼š

```rust
let mut inner = self.shared.queue.lock().unwrap();
// ... å‡è®¾è¯»ä¸åˆ°æ•°æ®
// ä½¿ç”¨ condvar å’Œ MutexGuard é˜»å¡çº¿ç¨‹
self.shared.available.wait(inner)
```


### éœ€æ±‚ 4
é¡ºç€åˆšæ‰çš„å¤šä¸ª sender æƒ³ï¼Œ å¦‚æœç°åœ¨æ‰€æœ‰ `Sender` éƒ½é€€å‡ºä½œç”¨åŸŸï¼Œ `Receiver` ç»§ç»­æ¥æ”¶ï¼Œ åˆ°æ²¡æœ‰æ•°æ®å¯è¯»äº†ï¼Œ è¯¥æ€ä¹ˆå¤„ç†ï¼Ÿ æ˜¯ä¸æ˜¯åº”è¯¥äº§ç”Ÿä¸€ä¸ªé”™è¯¯ï¼Œ è®©è°ƒç”¨è€…çŸ¥é“ï¼Œ ç°åœ¨ channel çš„å¦ä¸€ä¾§å·²ç»æ²¡æœ‰ç”Ÿäº§è€…äº†ï¼Œ å†è¯»ä¹Ÿè¯»ä¸å‡ºæ•°æ®äº†ï¼Ÿ

```rust
#[test]
fn last_sender_drop_should_error_when_receive() {
	let (s, mut r) = unbounded();
	let s1 = s.clone();
	let senders = [s, s1];
	let total = senders.len();

	// sender å³ç”¨å³æŠ›
	for mut sender in senders {
		thread::spawn(move || {
			sender.send("hello").unwrap();
			// sender åœ¨æ­¤è¢«ä¸¢å¼ƒ
		})
		.join()
		.unwrap();	
	}

	// è™½ç„¶æ²¡æœ‰ sender äº†ï¼Œæ¥æ”¶è€…ä¾ç„¶å¯ä»¥æ¥å—å·²ç»åœ¨é˜Ÿåˆ—é‡Œçš„æ•°æ®
	for _ in 0..total {
		r.recv().unwrap();
	}

	// ç„¶è€Œï¼Œè¯»å–æ›´å¤šæ•°æ®æ—¶ä¼šæŠ¥é”™
	assert!(r.recv().is_err());
}
```

è¿™ä¸ªæµ‹è¯•ä¾æ—§å¾ˆç®€å•ã€‚ ä½ å¯ä»¥æƒ³è±¡ä¸€ä¸‹ï¼Œä½¿ç”¨ä»€ä¹ˆæ ·çš„æ•°æ®ç»“æ„å¯ä»¥è¾¾åˆ°è¿™æ ·çš„ç›®çš„ã€‚ é¦–å…ˆï¼Œ æ¯æ¬¡ `Clone` æ—¶ï¼Œ è¦å¢åŠ  `Sender` çš„è®¡æ•°ï¼›åœ¨ `Sender` Drop æ—¶ï¼Œå‡å°‘è¿™ä¸ªè®¡æ•°ï¼›ç„¶åï¼Œæˆ‘ä»¬ä¸º `Receiver` æä¾›ä¸€ä¸ªæ–¹æ³• `total_senders()`ï¼Œ æ¥è¯»å– Sender çš„è®¡æ•°ï¼Œ å½“è®¡æ•°ä¸º 0ï¼Œ ä¸”é˜Ÿåˆ—ä¸­æ²¡æœ‰æ•°æ®å¯è¯»æ—¶ï¼Œ `recv()` æ–¹æ³•å°±æŠ¥é”™ã€‚

å“ˆï¼Œä½ ä¸€å®šæƒ³åˆ°äº†å¯ä»¥ä½¿ç”¨ atomicsã€‚ å¯¹ï¼Œ æˆ‘ä»¬å¯ä»¥ç”¨ `AtomicUsize`ã€‚ æ‰€ä»¥ï¼Œ `Shared` æ•°æ®ç»“æ„éœ€è¦æ›´æ–°ä¸€ä¸‹ï¼š

```rust
struct Shared<T> {
	queue: Mutex<VecDeque<T>>,
	available: Condvar,
	senders: AtomicUsize
}
```
### éœ€æ±‚ 5
æ—¢ç„¶æ²¡æœ‰ `Sender` äº†è¦æŠ¥é”™ï¼Œ é‚£ä¹ˆå¦‚æœæ²¡æœ‰ `Receiver` äº†ï¼Œ `Sender` å‘é€æ—¶æ˜¯ä¸æ˜¯ä¹Ÿåº”è¯¥é”™è¯¯è¿”å›ï¼Ÿ

```rust
#[test]
fn receiver_drop_should_error_when_send() {
	let (mut s1, mut s2) = {
		let (s, _) = unbounded();
		let s1 = s.clone();
		let s2 = s.clone();
		(s1, s2)	
	};

	assert!(s1.send(1).is_err());
	assert!(s2.send(2).is_err());
}
```

åŒæ ·åœ°ï¼Œ `Shared` æ•°æ®ç»“æ„è¦æ›´æ–°ä¸€ä¸‹ï¼š

```rust
struct Shared<T> {
	queue: Mutex<VecDeque<T>>,
	available: Condvar,
	sender: AtomicUsize,
	receiver: AtomicUsize
}
```


## å®ç° MPSC Channel
åˆ›å»ºä¸€ä¸ªæ–°çš„é¡¹ç›® `cargo new con_utils --lib`ã€‚ åœ¨ `Cargo.toml` ä¸­æ·»åŠ  `anyhow` ä½œä¸ºä¾èµ–ã€‚ åœ¨ `lib.rs` é‡Œï¼Œæˆ‘ä»¬å°±å†™å…¥ä¸€å¥ï¼š `pub mod channel` , ç„¶ååˆ›å»º `src/channel.rs`ï¼Œ æŠŠåˆšæ‰è®¾è®¡æ—¶ä½¿ç”¨çš„ test caseã€è®¾è®¡çš„æ•°æ®ç»“æ„ï¼Œä»¥åŠ test case é‡Œä½¿ç”¨åˆ°çš„æ¥å£ï¼Œç”¨ä»£ç å…¨éƒ¨æ”¾è¿›æ¥ï¼š

```rust
use anyhow::Result;
use std::{collections::VecDeque, sync::{atomic::AtomicUsize, Arc, Condvar, Mutex}};

/// å‘é€è€…
pub struct Sender<T> {
	shared: Arc<Shared<T>>
}

/// æ¥æ”¶è€…
pub struct Receiver<T> {
	shared: Arc<Shared<T>>
}

/// å‘é€è€…å’Œæ¥æ”¶è€…ä¹‹é—´å…±äº«ä¸€ä¸ª VecDeque, ç”¨ Mutex äº’æ–¥ï¼Œç”¨ Condvar é€šçŸ¥
/// åŒæ—¶ï¼Œæˆ‘ä»¬è®°å½•æœ‰å¤šå°‘ä¸ª senders å’Œ receivers

struct Shared<T> {
	queue: Mutex<VecDeque<T>>,
	available: Condvar,
	senders: AtomicUsize,
	receivers: AtomicUsize
}

impl<T> Sender<T> {
	/// ç”Ÿäº§è€…å†™å…¥ä¸€ä¸ªæ•°æ®
	pub fn send(&mut self, t: T) -> Result<()> {
		todo!()
	}

	pub fn total_receivers(&self) -> usize {
		todo!()
	}

	pub fn total_queued_items(&self) -> usize {
		todo!()
	}
}

impl<T> Receiver<T> {
	pub fn recv(&mut self) -> Result<T> {
		todo!()
	}

	pub fn total_senders(&self) -> usize {
		todo!()
	}
}

impl<T> Iterator for Receiver<T> {
	type Item = T;
	fn next(&mut self) -> Option<Self::Item> {
		todo!()
	}
}

/// å…‹éš† Sender
impl<T> Clone for Sender<T> {
	fn clone(&self) -> Self {
		todo!()
	}
}

/// Drop Sender
impl<T> Drop for Sender<T> {
	fn drop(&mut self) {
		todo!()
	}
}

impl<T> Drop for Receiver<T> {
	fn drop(&mut self) {
		todo!()
	}
}

/// åˆ›å»ºä¸€ä¸ª unbounded channel
pub fn unbounded<T>() -> (Sender<T>, Receiver<T>) {
	todo!()
}

#[cfg(test)]
mod tests {
	use std::{thread, time::Duration};
	use super::*;

	// æ­¤å¤„çœç•¥æ‰€æœ‰çš„ test case
}
```

### åˆ›å»º unbounded channel
```rust
pub fn unbounded<T>() -> (Sender<T>, Receiver<T>) {
	let shared = Shared::default();
	let shared = Arc::new(shared);
	(
		Sender {
			shared: shared.clone()
		},
		Receiver {shared}	
	)
}

const INITIAL_SIZE: usize = 32;
impl<T> Default for Shared<T> {
	fn default() -> Self {
		Self {
			queue: Mutex::new(VecDeque::with_capacity(INITIAL_SIZE)),
			available: Condvar::new(),
			senders: AtomicUsize::new(1),
			receivers: AtomicUsize::new(1)
		}
	}
}
```

å› ä¸ºè¿™é‡Œä½¿ç”¨ `default()` åˆ›å»ºäº† `Shared<T>`Â ç»“æ„ï¼Œ æ‰€ä»¥æˆ‘ä»¬éœ€è¦ä¸ºå…¶å®ç° `Default`ã€‚ åˆ›å»ºæ—¶ï¼Œ æˆ‘ä»¬æœ‰ 1 ä¸ªç”Ÿäº§è€…å’Œ 1 ä¸ªæ¶ˆè´¹è€…ã€‚

### å®ç°æ¶ˆè´¹è€…
å¯¹äºæ¶ˆè´¹è€…ï¼Œæˆ‘ä»¬ä¸»è¦å®ç° `recv` æ–¹æ³•ï¼Œ åœ¨ `recv` ä¸­ï¼Œ å¦‚æœé˜Ÿåˆ—ä¸­æœ‰æ•°æ®ï¼Œ é‚£ä¹ˆç›´æ¥è¿”å›ï¼› å¦‚æœæ²¡æ•°æ®ï¼Œ ä¸”æ‰€æœ‰ç”Ÿäº§è€…éƒ½ç¦»å¼€äº†ï¼Œ æˆ‘ä»¬å°±è¿”å›é”™è¯¯ï¼›  å¦‚æœæ²¡æ•°æ®ï¼Œ ä½†è¿˜æœ‰ç”Ÿäº§è€…ï¼Œ æˆ‘ä»¬å°±é˜»å¡æ¶ˆè´¹è€…çš„çº¿ç¨‹ï¼š

```rust
impl<T> Receiver<T> {
	fn recv(&mut self) -> Result<T> {
		// æ‹¿åˆ°é˜Ÿåˆ—çš„é”
		let mut inner = self.shared.queue.lock().unwrap();
		loop {
			match inner.pop_front() {
				// è¯»åˆ°æ•°æ®è¿”å›ï¼Œé”è¢«é‡Šæ”¾
				Some(t) => {
					return Ok(t)
				},
				// è¯»ä¸åˆ°æ•°æ®ï¼Œå¹¶ä¸”ç”Ÿäº§è€…éƒ½é€€å‡ºäº†ï¼Œé‡Šæ”¾é”å¹¶è¿”å›é”™è¯¯
				None if self.total_senders() == 0 => {
					return Err(anyhow!("no sender left"));
				},
				// è¯»ä¸åˆ°æ•°æ®ï¼ŒæŠŠé”æäº¤ç»™ available Condvar, å®ƒä¼šé‡Šæ”¾é”å¹¶æŒ‚èµ·çº¿ç¨‹ï¼Œç­‰å¾… notify
				None {
					inner = self.shared.available.wait(inner).map_err(|_| anyhow!("lock poisoned"))?;
				}
			}
		}	
	}

	pub fn total_senders(&self) -> usize {
		self.shared.senders.load(Ordering::SeqCst)
	}
}
```

æ³¨æ„çœ‹è¿™é‡Œ `Condvar` çš„ä½¿ç”¨ã€‚ åœ¨ `wait()` æ–¹æ³•é‡Œï¼Œå®ƒæ¥æ”¶ä¸€ä¸ª `MutexGuard`ï¼Œ ç„¶åé‡Šæ”¾è¿™ä¸ª `Mutex`ï¼Œ æŒ‚èµ·çº¿ç¨‹ã€‚ç­‰å¾—åˆ°é€šçŸ¥åï¼Œ å®ƒä¼šå†è·å–é”ï¼Œ å¾—åˆ°ä¸€ä¸ª `MutexGuard`ï¼Œ è¿”å›ã€‚ æ‰€ä»¥è¿™é‡Œæ˜¯ï¼š

```rust
inner = self.shared.availabel.wait(inner).map_err(|_| anyhow!("lock poisoned"))?;
```

å› ä¸º `recv()` ä¼šè¿”å›ä¸€ä¸ªå€¼ï¼Œæ‰€ä»¥é˜»å¡å›æ¥ä¹‹åï¼Œæˆ‘ä»¬åº”è¯¥å¾ªç¯å›å»æ‹¿æ•°æ®ã€‚è¿™æ˜¯ä¸ºä»€ä¹ˆè¿™æ®µé€»è¾‘è¦è¢« `loop {}` åŒ…è£¹ã€‚

è®°å¾—è¿˜è¦å¤„ç†æ¶ˆè´¹è€…çš„ `drop`ï¼š

```rust
impl<T> Drop for Receiver<T> {
	self.shared.receivers.fetch_sub(1, Ordering::ActRel);
}
```

### å®ç°ç”Ÿäº§è€…
é¦–å…ˆï¼Œåœ¨æ²¡æœ‰æ¶ˆè´¹è€…çš„æƒ…å†µä¸‹ï¼Œåº”è¯¥æŠ¥é”™ã€‚å¦‚æœæ¶ˆè´¹è€…è¿˜åœ¨ï¼Œé‚£ä¹ˆæˆ‘ä»¬è·å– `VecDeque` çš„é”ï¼ŒæŠŠæ•°æ®å‹å…¥ï¼š

```rust
impl<T> Sender<T> {
	/// ç”Ÿäº§è€…å†™å…¥ä¸€ä¸ªæ•°æ®
	pub fn send(&mut self, t: T) -> Result<()> {
		/// å¦‚æœæ²¡æœ‰æ¶ˆè´¹è€…ï¼Œå†™å…¥æ—¶å‡ºé”™
		if self.total_receivers() == 0 {
			return Err(anyhow!("no receiver left"));
		}

		/// åŠ é”ï¼Œè®¿é—® VecDeque, å‹å…¥æ•°æ®ï¼Œç„¶åç«‹åˆ»é‡Šæ”¾é”
		let was_empty = {
			let mut inner = self.shared.queue.lock().unwrap();
			let empty = inner.is_empty();
			inner.push_back(t);
			empty
		};

		/// é€šçŸ¥ä»»æ„ä¸€ä¸ªè¢«æŒ‚èµ·ç­‰å¾…çš„æ¶ˆè´¹è€…æœ‰æ•°æ®
		if was_empty {
			self.shared.available.notify_one()
		}

		Ok(())
	}

	pub fn total_receivers(&self) -> usize {
		self.shared.receivers.load(Ordering::SeqCst)
	}

	pub fn total_queued_items(&self) -> usize {
		let queue = self.shared.queue.lock().unwrap();
		queue.len()
	}
}
```

è¿™é‡Œï¼Œ è·å– `total_receivers` æ—¶ï¼Œæˆ‘ä»¬ä½¿ç”¨äº† `Ordering::SeqCst`ï¼Œ ä¿è¯æ‰€æœ‰çº¿ç¨‹çœ‹åˆ°åŒæ ·é¡ºåºçš„å¯¹ `receivers` çš„æ“ä½œã€‚ è¿™ä¸ªå€¼æ˜¯æœ€æ–°çš„å€¼ã€‚

**åœ¨å‹å…¥æ•°æ®æ—¶ï¼Œéœ€è¦åˆ¤æ–­ä¸€ä¸‹ä¹‹å‰æ˜¯é˜Ÿåˆ—æ˜¯å¦ä¸ºç©ºï¼Œå› ä¸ºé˜Ÿåˆ—ä¸ºç©ºçš„æ—¶å€™ï¼Œæˆ‘ä»¬éœ€è¦ç”¨ notify_one() æ¥å”¤é†’æ¶ˆè´¹è€…ã€‚**

ç”±äºæˆ‘ä»¬å¯ä»¥æœ‰å¤šä¸ªç”Ÿäº§è€…ï¼Œæ‰€ä»¥è¦å…è®¸å®ƒ `clone`:

```rust
impl<T> Clone for Sender<T> {
	fn clone(&self) -> Self {
		self.shared.senders.fetch_add(1, Ordering::AcqRel);
		Self {
			shared: Arc::clone(&self.shared)
		}
	}
}
```

å½“ç„¶ï¼Œåœ¨ `drop` çš„æ—¶å€™æˆ‘ä»¬ä¹Ÿè¦ç»´æŠ¤ `shared.senders` ä½¿å…¶å‡ 1ï¼š

```rust
impl<T> Drop for Sender<T> {
	fn drop(&mut self) {
		self.shared.senders.fetch_sub(1, Ordering::AcqRel);
	}
}
```

### å…¶ä»–åŠŸèƒ½
ç›®å‰è¿˜ç¼ºä¹ `Receiver` çš„ `Iterator` çš„å®ç°ï¼Œ è¿™ä¸ªå¾ˆç®€å•ï¼Œ å°±æ˜¯åœ¨ `next()` é‡Œè°ƒç”¨ `recv()` æ–¹æ³•ï¼Œ Rust æä¾›äº†æ”¯æŒåœ¨ `Option / Result` ä¹‹é—´å¾ˆæ–¹ä¾¿è½¬æ¢çš„å‡½æ•°ï¼Œ æ‰€ä»¥è¿™é‡Œæˆ‘ä»¬å¯ä»¥ç›´æ¥é€šè¿‡ `ok()` æ¥å°† `Result` è½¬æ¢æˆ `Option`ï¼š

```rust
impl<T> Iterator for Receiver<T> {
	type Item = T;

	fn next(&mut self) -> Option<Self::Item> {
		self.recv().ok()
	}
}
```

æœ€åæ¥ä»”ç»†å®¡è§†ä¸€ä¸‹ä»£ç ã€‚ å¾ˆå¿«ï¼Œæˆ‘ä»¬å‘ç° `Sender` çš„ `Drop` å®ç°ä¼¼ä¹æœ‰ç‚¹é—®é¢˜ã€‚ å¦‚æœ `Receiver` è¢«é˜»å¡ï¼Œ è€Œæ­¤åˆ»æ‰€æœ‰ `Sender` éƒ½èµ°äº†ï¼Œ é‚£ä¹ˆ `Receiver` å°±æ²¡æœ‰äººå”¤é†’ï¼Œ ä¼šå¸¦æ¥èµ„æºçš„æ³„éœ²ã€‚ è¿™æ˜¯ä¸€ä¸ªå¾ˆè¾¹è¾¹è§’è§’çš„é—®é¢˜ï¼Œ æ‰€ä»¥ä¹‹å‰çš„æµ‹è¯•æ²¡æœ‰è¦†ç›–åˆ°ã€‚æˆ‘ä»¬æ¥è®¾è®¡ä¸€ä¸ªåœºæ™¯è®©è¿™ä¸ªé—®é¢˜æš´éœ²ï¼š

```rust
#[test]
fn receiver_shall_be_notified_when_all_senders_exit() {
	let (s, mut r) = unbounded::<usize>();
	// ç”¨äºä¸¤ä¸ªçº¿ç¨‹åŒæ­¥
	let (mut sender, mut receiver) = unbounded::<usize>();
	let t1 = thread::spawn(move || {
		// ä¿è¯ r.recv() å…ˆäº t2 çš„ drop æ‰§è¡Œ
		sender.send(0).unwrap();
		assert!(r.recv().is_err());
	});

	let t2 = thread::spawn(move || {
		receiver.recv().unwrap();
		drop(s);
	});

	t1.join().unwrap();
}
```

è¿™é‡Œï¼Œæˆ‘ä»¬åˆ›å»ºäº†ä¸¤ä¸ªçº¿ç¨‹ `t1` å’Œ `t2`ï¼Œåˆ†åˆ«è®©å®ƒä»¬å¤„ç†æ¶ˆè´¹è€…å’Œç”Ÿäº§è€…ã€‚**`t1` è¯»å–æ•°æ®ï¼Œ æ­¤æ—¶æ²¡æœ‰æ•°æ®ï¼Œ æ‰€ä»¥ä¼šé˜»å¡ï¼Œ è€Œ `t2` ç›´æ¥æŠŠç”Ÿäº§è€… `drop` æ‰ã€‚**  æ‰€ä»¥ï¼Œ æ­¤åˆ»å¦‚æœæ²¡æœ‰äººå”¤é†’ `t1`ï¼Œ é‚£ä¹ˆ `t1.join()` å°±ä¼šä¸€ç›´ç­‰å¾…ï¼Œå› ä¸º `t1` ä¸€ç›´æ²¡æœ‰é€€å‡ºã€‚æ‰€ä»¥ï¼Œä¸ºäº†ä¿è¯ä¸€å®šæ˜¯ `t1` çš„ `r.recv()` å…ˆæ‰§è¡Œå¯¼è‡´é˜»å¡ã€ `t2` å† `drop(s)`ï¼Œ æˆ‘ä»¬ï¼ˆeat your own dog foodï¼‰ç”¨å¦ä¸€ä¸ª channel æ¥æ§åˆ¶ä¸¤ä¸ªçº¿ç¨‹çš„æ‰§è¡Œé¡ºåºã€‚

è¦ä¿®å¤è¿™ä¸ªé—®é¢˜ï¼Œæˆ‘ä»¬éœ€è¦å¦¥å–„å¤„ç† `Sender` çš„ `Drop`ï¼š

```rust
impl<T> Drop for Sender<T> {
	fn drop(&mut self) {
		let old = self.shared.senders.fetch_sub(1, Ordering::AcqRel);
		// sender èµ°å…‰äº†ï¼Œå”¤é†’ receiver è¯»å–æ•°æ®ï¼ˆå¦‚æœé˜Ÿåˆ—ä¸­è¿˜æœ‰çš„è¯ï¼‰ï¼Œè¯»ä¸åˆ°å°±å‡ºé”™
		if old <= 1 {
			// å› ä¸ºæˆ‘ä»¬å®ç°çš„æ˜¯ MPSCï¼Œreceiver åªæœ‰ä¸€ä¸ªï¼Œæ‰€ä»¥ notify_all å®é™…ç­‰ä»· notify_one
			self.shared.availabel.notify_all();
		}
	}
}
```

è¿™é‡Œï¼Œå¦‚æœå‡ä¸€ä¹‹å‰ï¼Œæ—§çš„ `senders` çš„æ•°é‡å°äºç­‰äº 1ï¼Œæ„å‘³ç€ç°åœ¨æ˜¯æœ€åä¸€ä¸ª `Sender` è¦ç¦»å¼€äº†ï¼Œä¸ç®¡æ€æ ·æˆ‘ä»¬éƒ½è¦å”¤é†’ `Receiver` ï¼Œ æ‰€ä»¥è¿™é‡Œä½¿ç”¨äº† `notify_all()`ã€‚ å¦‚æœ `Receiver` ä¹‹å‰å·²ç»è¢«é˜»å¡ï¼Œ æ­¤åˆ»å°±èƒ½è¢«å”¤é†’ã€‚

## æ€§èƒ½ä¼˜åŒ–
ä»åŠŸèƒ½ä¸Šæ¥è¯´ï¼Œç›®å‰æˆ‘ä»¬çš„ `MPSC unbounded channel` æ²¡æœ‰å¤ªå¤šçš„é—®é¢˜ï¼Œå¯ä»¥åº”ç”¨åœ¨ä»»ä½•éœ€è¦ MPSC channel çš„åœºæ™¯ã€‚ç„¶è€Œï¼Œæ¯æ¬¡è¯»å†™éƒ½éœ€è¦è·å–é”ï¼Œè™½ç„¶é”çš„ç²’åº¦å¾ˆå°ï¼Œä½†è¿˜æ˜¯è®©æ•´ä½“çš„æ€§èƒ½æ‰“äº†ä¸ªæŠ˜æ‰£ã€‚æœ‰æ²¡æœ‰å¯èƒ½ä¼˜åŒ–é”å‘¢ï¼Ÿ

ä¹‹å‰æˆ‘ä»¬è®²åˆ°ï¼Œ ä¼˜åŒ–é”çš„æ‰‹æ®µæ— éæ˜¯**å‡å°ä¸´ç•ŒåŒºçš„å¤§å°**ï¼Œ è®©æ¯æ¬¡åŠ é”çš„æ—¶é—´å¾ˆçŸ­ï¼Œ è¿™æ ·å†²çªçš„å‡ ç‡å°±å˜å°ã€‚ å¦å¤–ï¼Œ å°±æ˜¯**é™ä½åŠ é”çš„é¢‘ç‡**ï¼Œ  å¯¹äºæ¶ˆè´¹è€…æ¥è¯´ï¼Œ å¦‚æœæˆ‘ä»¬èƒ½å¤Ÿä¸€æ¬¡æ€§æŠŠé˜Ÿåˆ—ä¸­çš„æ‰€æœ‰æ•°æ®éƒ½è¯»å®Œç¼“å­˜èµ·æ¥ï¼Œ ä»¥ååœ¨éœ€è¦çš„æ—¶å€™ä»ç¼“å­˜ä¸­è¯»å–ï¼Œ è¿™æ ·å°±å¯ä»¥å¤§å¤§å‡å°‘æ¶ˆè´¹è€…åŠ é”çš„é¢‘æ¬¡ã€‚

é¡ºç€è¿™ä¸ªæ€è·¯ï¼Œæˆ‘ä»¬å¯ä»¥åœ¨ `Receiver` çš„ç»“æ„ä¸­æ”¾ä¸€ä¸ª `cache`:

```rust
pub struct Receiver {
	shared: Arc<Shared<T>>,
	cache: VecDeque<T>
}
```

å¦‚æœä½ ä¹‹å‰æœ‰ C è¯­è¨€å¼€å‘çš„ç»éªŒï¼Œ ä¹Ÿè®¸ä¼šæƒ³ï¼Œ åˆ°äº†è¿™ä¸€æ­¥ï¼Œ ä½•å¿…æŠŠ `queue` ä¸­çš„æ•°æ®å…¨éƒ¨è¯»å‡ºæ¥ï¼Œ å­˜å…¥ `Receiver` çš„ `cache` å‘¢ï¼Ÿ è¿™æ ·æ•ˆç‡å¤ªä½ï¼Œ å¦‚æœèƒ½å¤Ÿç›´æ¥ swap ä¸¤ä¸ªç»“æ„å†…éƒ¨çš„æŒ‡é’ˆï¼Œ è¿™æ ·ï¼Œ å³ä¾¿é˜Ÿåˆ—ä¸­æœ‰å†å¤šçš„æ•°æ®ï¼Œ ä¹Ÿæ˜¯ä¸€ä¸ª O(1) çš„æ“ä½œã€‚

Rust æœ‰ç±»ä¼¼çš„ `std::mem::swap` æ–¹æ³•ã€‚æ¯”å¦‚

```rust
use std::mem;

fn main() {
	let mut x = "hello world".to_string();
	let mut y = "goodby world".to_string();

	mem::swap(&mut x, &mut y);

	assert_eq!("goodbye world", x);
	assert_eq!("hello world", y);
}
```

å¥½ï¼Œäº†è§£äº† swap æ–¹æ³•ï¼Œæˆ‘ä»¬çœ‹çœ‹å¦‚ä½•ä¿®æ”¹ `Receiver` çš„ `recv()` æ–¹æ³•æ¥æå‡æ€§èƒ½ï¼š

```rust
pub fn recv(&mut self) -> Result<T> {
	// æ— é” fast path
	if let Some(v) = self.cache.pop_front() {
		return Ok(v);
	}

	// æ‹¿åˆ°é˜Ÿåˆ—çš„é”
	let mut inner = self.shared.lock().unwrap();
	loop {
		match inner.pop_front() {
			// è¯»åˆ°æ•°æ®è¿”å›ï¼Œé”è¢«é‡Šæ”¾
			Some(t) => {
				// å¦‚æœå½“å‰é˜Ÿåˆ—ä¸­è¿˜æœ‰æ•°æ®ï¼Œé‚£ä¹ˆå°±æŠŠæ¶ˆè´¹è€…è‡ªèº«ç¼“å­˜çš„é˜Ÿåˆ—ï¼ˆç©ºï¼‰å’Œå…±äº«é˜Ÿåˆ— swap ä¸€ä¸‹ 
				// è¿™æ ·ä¹‹åå†è¯»å–ï¼Œå°±å¯ä»¥ä» self.queue ä¸­æ— é”è¯»å–
				if !inner.is_empty() {
					std::mem::swap(&mut self.cache, &mut inner);
				}
				return Ok(t)
			}
			// è¯»ä¸åˆ°æ•°æ®ï¼Œå¹¶ä¸”ç”Ÿäº§è€…éƒ½é€€å‡ºäº†ï¼Œé‡Šæ”¾é”å¹¶è¿”å›é”™è¯¯
			None if self.total_senders() == 0 => return Err(anyhow!("no sender left")),
			// è¯»ä¸åˆ°æ•°æ®ï¼ŒæŠŠé”æäº¤ç»™ available Condvarï¼Œå®ƒä¼šé‡Šæ”¾é”å¹¶æŒ‚èµ·çº¿ç¨‹ï¼Œç­‰å¾… notify
			None => {
				inner = self.shared.available.wait(inner).map_err(|_| anyhow!("lock poinsoned"))?;
			}
		}
	}
}
```

å½“ `cache` ä¸­æœ‰æ•°æ®æ—¶ï¼Œæ€»æ˜¯ä» `cache` ä¸­è¯»å–ï¼›å½“ `cache` ä¸­æ²¡æœ‰ï¼Œæˆ‘ä»¬æ‹¿åˆ°é˜Ÿåˆ—çš„é”ï¼Œè¯»å–ä¸€ä¸ªæ•°æ®ï¼Œç„¶åçœ‹çœ‹é˜Ÿåˆ—æ˜¯å¦è¿˜æœ‰æ•°æ®ï¼Œæœ‰çš„è¯ï¼Œå°± swap `cache` å’Œ `queue`ï¼Œç„¶åè¿”å›ä¹‹å‰è¯»å–çš„æ•°æ®ã€‚

è™½ç„¶ç°æœ‰çš„æµ‹è¯•å…¨æ•°é€šè¿‡ï¼Œä½†æˆ‘ä»¬å¹¶æ²¡æœ‰ä¸ºè¿™ä¸ªä¼˜åŒ–å†™æµ‹è¯•ï¼Œè¿™é‡Œè¡¥ä¸ªæµ‹è¯•ï¼š

```rust
#[test]
fn channel_fast_path_should_work() {
	let (mut s, mut r) = unbounded();
	for i in 0..10usize {
		s.send(i).unwrap();
	}

	assert!(r.cache.is_empty());
	// è¯»å–ä¸€ä¸ªæ•°æ®ï¼Œæ­¤æ—¶åº”è¯¥ä¼šå¯¼è‡´ swapï¼Œcache ä¸­æœ‰æ•°æ®
	assert_eq!(0, r.recv().unwrap());
	// è¿˜æœ‰ 9 ä¸ªæ•°æ®åœ¨ cache ä¸­
	assert_eq!(r.cache.len(), 9);
	// åœ¨ queue é‡Œæ²¡æœ‰æ•°æ®äº†
	assert_eq!(s.total_queued_items(), 0);

	// ä» cache é‡Œè¯»å–å‰©ä¸‹çš„æ•°æ®
	for (idx, i) in r.into_iter().take(9).enumerate() {
		assert_eq!(idx+1, i);
	}
}
```
## å°ç»“
ä¸åŒäºä»¥å¾€çš„å®æ“é¡¹ç›®ï¼Œ è¿™ä¸€è®²ï¼Œ æˆ‘ä»¬å®Œå…¨é¡ºç€éœ€æ±‚å†™æµ‹è¯•ï¼Œ ç„¶ååœ¨å†™æµ‹è¯•çš„è¿‡ç¨‹ä¸­è¿›è¡Œæ•°æ®ç»“æ„å’Œæ¥å£çš„è®¾è®¡ã€‚ å’Œæ™®é€šçš„ TDD ä¸åŒçš„æ˜¯ï¼Œ æˆ‘ä»¬**å…ˆä¸€å£æ°”æŠŠä¸»è¦éœ€æ±‚æ¶‰åŠçš„è¡Œä¸ºç”¨æµ‹è¯•æ¥è¡¨è¿°ï¼Œ ç„¶åé€šè¿‡è¿™ä¸ªè¡¨è¿°ï¼Œ æ„å»ºåˆé€‚çš„æ¥å£ï¼Œ ä»¥åŠèƒ½å¤Ÿè¿è¡Œè¿™ä¸ªæ¥å£çš„æ•°æ®ç»“æ„ã€‚**
# é‡ç‚¹æ‘˜è¦
> [!tip] 
> åœ¨å®Œæˆã€Œç¬¬ä¸€å±‚ï¼šåŸæ–‡æ‘˜è¦ã€åé©¬ä¸Šå°±æ•´ç†ã€Œç¬¬äºŒå±‚ï¼šé‡ç‚¹æ‘˜è¦ã€ï¼Œè™½ç„¶éœ€è¦éµå¾ªã€Œä¸åŒçš„æ—¶é—´æ®µå®Œæˆä¸åŒå±‚çº§ã€çš„è§„åˆ™ï¼Œä½†æ˜¯åœ¨é˜…è¯»æˆ–æ•´ç†ç¬”è®°çš„å½“ä¸‹ï¼Œå¦‚æœè§‰å¾—æœ‰äº›å†…å®¹éœ€è¦é‡ç‚¹æ ‡æ³¨ï¼Œéœ€è¦ç¬¬ä¸€æ—¶é—´å°†ã€Œç¬¬ä¸€å±‚ã€å†…å®¹æ‹·è´åˆ°ã€Œç¬¬äºŒå±‚ã€è¿›è¡Œã€Œé‡ç‚¹æ ‡æ³¨ã€ï¼ŒåŒæ—¶å¦‚æœæœ‰å¿…è¦ä¹Ÿå¯ä»¥æ·»åŠ è‡ªå·±çš„ã€Œæ³¨é‡Šã€ï¼Œæ–¹ä¾¿è¿›è¡Œè¾…åŠ©ç†è§£

# é•¿é’ç¬”è®°
> [!tip]
>  å¸¸é’ç¬”è®°ï¼Œä¹Ÿç§°ä¸ºæ°¸ä¹…ç¬”è®°ã€‚å¦‚æœå½“å‰ç¬”è®°çš„é˜…è¯»è®©ä½ äº§ç”Ÿäº†æ–°çš„çµæ„Ÿï¼Œç«™åœ¨ã€ŒåŸå§‹ç´ æã€çš„åŸºç¡€ä¸Šå†™ä¸€ç¯‡æ–‡ç« ï¼Œç„¶åé€šè¿‡ã€ŒåŒå‘é“¾æ¥ã€å°†ç¬”è®°æ·»åŠ åˆ°ã€Œç¬¬ä¸‰å±‚ï¼šå¸¸é’ç¬”è®°ã€ä¸­

# é—ªå¿µ
> [!tip]
> è¿™ä¸€å±‚ä¸»è¦å­˜æ”¾é‚£äº›ã€Œçµå…‰ä¸€ç°ã€çš„å†…å®¹ï¼Œå½“é˜…è¯»ç¬”è®°çš„å½“ä¸‹çªç„¶æŸä¸€æ®µå†…å®¹äº§ç”Ÿäº†ä¸€äº›çµæ„Ÿï¼Œéšæ‰‹è®°å½•åœ¨ã€Œç¬¬å››å±‚ã€ï¼Œå¹¶è®¾ç½®å¥½æ ‡ç­¾ã€Œé—ªå¿µèƒ¶å›Šã€æ–¹ä¾¿å°†æ¥ç´¢å¼•

# å›å½’é—®é¢˜
> [!tip] 
> ä½¿ç”¨å‡ ä¸ªé—®é¢˜ï¼Œå°†æœ¬ç¬”è®°å†…å®¹æ ¸å¿ƒçŸ¥è¯†æç‚¼å‡ºæ¥